[{"id":0,"href":"/Programming/Algorithm/Grind75/Array/TwoSum.html","title":"1. Two Sum","parent":"Array","content":" Two Sum 暴力解 兩個 loop 加起來等於 target, 就回傳他們的 index，應該是最新手最直覺的人（我）都想得出來的解答\n優化解 一樣是用兩個 loop 去解，但是這裡不是用 nested loop，而是先用一個 loop 以及 hashmap 把陣列裡的每個值標記起來 [index, value]，另一個 loop 再去對每個值做計算，如果 target - nums[i] 有在 hashmap裏面，就回傳 i 以及對應的 index\nclass Solution { public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; nums.length; i++) { hashmap.put(nums[i], i); } for (int i = 0; i \u0026lt; nums.length; i++) { int difference = target - nums[i]; if(hashmap.containsKey(difference) \u0026amp;\u0026amp; hashmap.get(difference) != i) { return new int[] {i, hashmap.get(difference)}; } } return new int[]{}; } } ","description":"Two Sum 暴力解 兩個 loop 加起來等於 target, 就回傳他們的 index，應該是最新手最直覺的人（我）都想得出來的解答\n優化解 一樣是用兩個 loop 去解，但是這裡不是用 nested loop，而是先用一個 loop 以及 hashmap 把陣列裡的每個值標記起來 [index, value]，另一個 loop 再去對每個值做計算，如果 target - nums[i] 有在 hashmap裏面，就回傳 i 以及對應的 index\nclass Solution { public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; nums.length; i++) { hashmap.put(nums[i], i); } for (int i = 0; i \u0026lt; nums.length; i++) { int difference = target - nums[i]; if(hashmap."},{"id":1,"href":"/Programming/Algorithm/Algs4Princeton/Week1/UnionFind/DynamicConnectivity.html","title":"Dynamic Connectivity","parent":"Union Find","content":" 前提 目的 相關應用 連接的定義 演算法實作 Union-find data type (API) 目標：為了union-find 設計一個有效率的資料結構 Union-find implementation[2] 參考來源 前提 Giving N objects\n目的 寫出演算法來完成以下兩點\nUnion command: connect two objects Find/connected query: Is there a path connecting the two objects? 假設給定的物件為 0,1,2,3,4,5,6,7,8,9，在執行完以下的union命令後，\nUnion(4, 3) Union(3, 8) Union(6, 5) Union(9, 4) Union(2, 1) connected(0, 7) // no connected connected(8, 9) // connected union(5, 0) union(7, 2) connected(0, 7) union(1, 0) // connected connectivity 的狀況會如下圖\n相關應用 數位照片的Pixels 在同一個網路的電腦 社群網站的好友 連接的定義 Reflexive: p 跟 p 自己連接 Symmetric: 若p跟q連接，q也跟p連接 Transitive: 若p跟q連接，q跟r連接，則p跟r連接 物件如果連接可以想成他們是在同一個component裏面，因此就剛剛的例子，會有2個component set\n{0,1,2,5,6,7} {3,4,8,9} 演算法實作 Find query: 檢查兩個物件是不是在相同的components Union command: 將兩個物件所在的component取聯集 Union-find data type (API) 目標：為了union-find 設計一個有效率的資料結構 其中\nNumber of object N can be huge. Number of operation M can be huge. Find queries and union commands may be intermixed(交錯進行). API 設計如下\npublic class UF --- UF(int N) // initialize N sites with integer names (0 to N-1) void union(int p, int q) // add connection between p and q int find(int p) // component identifier for p (0 to N-1) boolean connected(int p, int q) // return true if p and q are in the same component int count // number of components Union-find implementation[2] public class UF { private int[] id; // access to component id (site indexed) private int count; // number of components public UF(int n) { // Initialize component id array count = N; id = new int[N]; for (int i = 0; i \u0026lt; N; i++) { id[i] = i; } } public int count() { return count; } public boolean connected(int p, int q) { return find[p] == find[q]; } public int find(int p) { return id[p]; } public void union(int p, int q) { // Put p and q into the same component. int pID = find(p); int qID = find(q); // Nothing to do if p and q are already in the same component. if (pID == qID) return; // Rename p’s component to q’s name. for (int i = 0; i \u0026lt; id.length; i++) { if (id[i] == pID) id[i] = qID; count--; } } public static void main(String[] args) { // Read number of sites. int n = StdIn.readInt(); // Initialize N components. UF uf = new UF(n); while (!StdIn.isEmpty()) { int p = StdIn.readInt(); // Read pair to connect. int q = StdIn.readInt(); // Ignore if connected. if (uf.find(p) == uf.find(q)) continue; // Combine components uf.union(p, q); // Print connections. StdOut.println(p + \u0026#34; \u0026#34; + q); } StdOut.println(uf.count() + \u0026#34; components\u0026#34;); } } 參考來源 [1] Algorithms in Java, Lecture slide\n[2] Algorithms, 4th Edition\n","description":"前提 目的 相關應用 連接的定義 演算法實作 Union-find data type (API) 目標：為了union-find 設計一個有效率的資料結構 Union-find implementation[2] 參考來源 前提 Giving N objects\n目的 寫出演算法來完成以下兩點\nUnion command: connect two objects Find/connected query: Is there a path connecting the two objects? 假設給定的物件為 0,1,2,3,4,5,6,7,8,9，在執行完以下的union命令後，\nUnion(4, 3) Union(3, 8) Union(6, 5) Union(9, 4) Union(2, 1) connected(0, 7) // no connected connected(8, 9) // connected union(5, 0) union(7, 2) connected(0, 7) union(1, 0) // connected connectivity 的狀況會如下圖\n相關應用 數位照片的Pixels 在同一個網路的電腦 社群網站的好友 連接的定義 Reflexive: p 跟 p 自己連接 Symmetric: 若p跟q連接，q也跟p連接 Transitive: 若p跟q連接，q跟r連接，則p跟r連接 物件如果連接可以想成他們是在同一個component裏面，因此就剛剛的例子，會有2個component set"},{"id":2,"href":"/Programming/Algorithm/Algs4Princeton/Week2/StackAndQueue/Stacks.html","title":"Stacks","parent":"Stack And Queue","content":"my solution\n","description":"my solution"},{"id":3,"href":"/Programming/SiteStory/WhyHugo.html","title":"Why Hugo","parent":"Site Story","content":"\n為啥我搞了半天最後決定用 Hugo弄個網站？\n錯綜複雜的原因 斷斷續續的筆記習慣 VPS Domain 為了讓Domain的錢花得心安 Hugo 錯綜複雜的原因 會用Hugo架網站完全就是個意外，或許可以說是不同時間點覺得有趣的東西結合起來的結果。\n斷斷續續的筆記習慣 在轉職成為軟體工程師前，就有在記錄我最近學了什麼東西的習慣，原本是記在HackMD，但上班後就棄用了， 上班後用的東西就記在Apple Notes上，比較偏各專案得紀錄跟常用的指令。前陣子也有用過一陣子medium寫過幾篇刷題紀錄， 真的是幾篇就四篇吧 (而且都是複製別人的解法用自己的話重講一次，還都是easy)。\nVPS 跟Billy大神閒聊的時候知道他最近考過了AWS證照，夢想成為離前端越遠越好的軟體工程師的我很羨慕又欽佩，便在1 on 1的時候與主管聊起這話題，在主管的推薦下建議我可以先玩玩VPS，比起AWS單純也便宜，原理也都差不多，熟悉之後去用AWS會比較快上手因為AWS實在太雜了。\n然後我就馬上開了一開VPS起來然後發現我不知道要幹嘛\u0026hellip; 就又關掉了。\nDomain 做某專案的時候要請客戶提供Domain讓我們設定，或是我們幫他們弄一組，但我一開始完全不知道這些東西如何去用專業術語溝通，就問了旁邊的同事，發現他熟的跟啥一樣，我跟他比起來大概是全熟的牛排VS旁邊的生菜。\n後來知道他有在架NAS，也有買自己的Domain，還親手登入後台設定一遍給我看。聽到他有自己的domain我眼睛都亮起來了，感覺超屌，心想我一定也要一個自己的Domain。\n為了讓Domain的錢花得心安 接著好一陣子我每天朝思暮想要買一個domain，也去Godaddy上面瞎晃，不過畢竟 我也不是啥有錢人，買domain一定要物盡其用，只能為了說服我自己買domain而努力找出一個用途來，最好還要對我的職業生涯很有幫助。\n最後想著想著突然想到我可以用WordPress弄個blog來寫學習筆記，綁上我的domain！咦～聽起來不錯，便開始利用通勤時研究WordPress怎麼弄。\nHugo WordPress研究了半天，也不時看到其他架靜態blog的工具，發現這東西真是五花八門，馬上就又稍微研究了一下 (真的只有稍微)。\nJekyll：Ruby寫的，沒什麼感覺 Hugo：Go寫的，好像很潮 Hexo：Node.js寫的，直接刪掉 刪掉了Jekyll跟Hexo最後在wordpress跟Hugo選一個，一開始還是有點猶豫不決，最後壓垮我的倒數第二根稻草是看到一篇 Hugo+Github Action 自動部署到 VPS 的文章， 心裡想哇靠這不是把我的三個願望一次完成了嗎？還多點了一滴滴CI/CD。\n最後一根稻草是也去看了一下技術名人的網站，看到 良葛格的新網站 也是用Hugo架的，整個簡潔又專業。\n因此最後，就決定是Hugo了\n","description":"為啥我搞了半天最後決定用 Hugo弄個網站？\n錯綜複雜的原因 斷斷續續的筆記習慣 VPS Domain 為了讓Domain的錢花得心安 Hugo 錯綜複雜的原因 會用Hugo架網站完全就是個意外，或許可以說是不同時間點覺得有趣的東西結合起來的結果。\n斷斷續續的筆記習慣 在轉職成為軟體工程師前，就有在記錄我最近學了什麼東西的習慣，原本是記在HackMD，但上班後就棄用了， 上班後用的東西就記在Apple Notes上，比較偏各專案得紀錄跟常用的指令。前陣子也有用過一陣子medium寫過幾篇刷題紀錄， 真的是幾篇就四篇吧 (而且都是複製別人的解法用自己的話重講一次，還都是easy)。\nVPS 跟Billy大神閒聊的時候知道他最近考過了AWS證照，夢想成為離前端越遠越好的軟體工程師的我很羨慕又欽佩，便在1 on 1的時候與主管聊起這話題，在主管的推薦下建議我可以先玩玩VPS，比起AWS單純也便宜，原理也都差不多，熟悉之後去用AWS會比較快上手因為AWS實在太雜了。\n然後我就馬上開了一開VPS起來然後發現我不知道要幹嘛\u0026hellip; 就又關掉了。\nDomain 做某專案的時候要請客戶提供Domain讓我們設定，或是我們幫他們弄一組，但我一開始完全不知道這些東西如何去用專業術語溝通，就問了旁邊的同事，發現他熟的跟啥一樣，我跟他比起來大概是全熟的牛排VS旁邊的生菜。\n後來知道他有在架NAS，也有買自己的Domain，還親手登入後台設定一遍給我看。聽到他有自己的domain我眼睛都亮起來了，感覺超屌，心想我一定也要一個自己的Domain。\n為了讓Domain的錢花得心安 接著好一陣子我每天朝思暮想要買一個domain，也去Godaddy上面瞎晃，不過畢竟 我也不是啥有錢人，買domain一定要物盡其用，只能為了說服我自己買domain而努力找出一個用途來，最好還要對我的職業生涯很有幫助。\n最後想著想著突然想到我可以用WordPress弄個blog來寫學習筆記，綁上我的domain！咦～聽起來不錯，便開始利用通勤時研究WordPress怎麼弄。\nHugo WordPress研究了半天，也不時看到其他架靜態blog的工具，發現這東西真是五花八門，馬上就又稍微研究了一下 (真的只有稍微)。\nJekyll：Ruby寫的，沒什麼感覺 Hugo：Go寫的，好像很潮 Hexo：Node.js寫的，直接刪掉 刪掉了Jekyll跟Hexo最後在wordpress跟Hugo選一個，一開始還是有點猶豫不決，最後壓垮我的倒數第二根稻草是看到一篇 Hugo+Github Action 自動部署到 VPS 的文章， 心裡想哇靠這不是把我的三個願望一次完成了嗎？還多點了一滴滴CI/CD。\n最後一根稻草是也去看了一下技術名人的網站，看到 良葛格的新網站 也是用Hugo架的，整個簡潔又專業。\n因此最後，就決定是Hugo了"},{"id":4,"href":"/Programming/Algorithm/Grind75/Array.html","title":"Array","parent":"Grind 75","content":" 1. Two Sum 121. Best Time to Buy and Sell Stock 169. Majority Element 217. Contains Duplicate 57. Insert Interval 15. Three Sum 238. Product of Array Except Self 39. Combination Sum ","description":" 1. Two Sum 121. Best Time to Buy and Sell Stock 169. Majority Element 217. Contains Duplicate 57. Insert Interval 15. Three Sum 238. Product of Array Except Self 39. Combination Sum "},{"id":5,"href":"/Programming/Languages/PHP.html","title":"PHP","parent":"Language","content":" PHP UNIT ","description":" PHP UNIT "},{"id":6,"href":"/Programming/Algorithm/Algs4Princeton/Week1/UnionFind.html","title":"Union Find","parent":"Week 1","content":" Dynamic Connectivity Quick Find Quick Union Weighted Quick Union ","description":" Dynamic Connectivity Quick Find Quick Union Weighted Quick Union "},{"id":7,"href":"/Programming/Algorithm/Algs4Princeton/Week1.html","title":"Week 1","parent":"Princeton Algorithms","content":" Union Find Dynamic Connectivity Quick Find Quick Union Weighted Quick Union ","description":" Union Find Dynamic Connectivity Quick Find Quick Union Weighted Quick Union "},{"id":8,"href":"/Programming/Algorithm/Grind75/Array/BestTimeToBuyAndSellStock.html","title":"121. Best Time to Buy and Sell Stock","parent":"Array","content":" 解題思路 要如何算出最大收益？ 買的價格越低，賣的價格越高。\n但因為買的時間一定要比賣的時間早，所以只能由左至右開始搜尋（index 從 0 開始）\n一開始也只能知道一開始的收益以及目前的金額\n假如給定的價格列表為[7,1,5,3,6,4]\n一開始的收益為 profit = 0\n一開始的金額是 prices [0]\n如果是第一天買股票，第二天賣\n這時候的收益會是 1 - 7 = - 6\n再往後計算的話\n如果是第一天買，第三天賣\n這時候的收益會是 5 - 7 = - 2\n看起來比第一天買第二天賣還要賺（虧比較少）\n但這時發現了一件事，第二天的價格比第一天還要低， 這樣根本不用再去管第一天的價格是多少，因為用第二天的價格 (1) 當買入價來繼續計算， 算出來的收益一定會比用第一天的價格 (7) 當買入價還要划算。 而且時間不能重來。\n因此可以在計算價差時，發現最低價的時候就更新最低價的值， 計算價差的時候就只要用後續的價格 - 最低價即可得到最大收益。\n依照範例給的數據會得到以下結果：\nProfit = price[index] - min 1 - 7 = -6 Min = 1 1 - 1 = 0, min = 1 5 - 1 = 4, min = 1, profit = 0 3 - 1 = 2, min = 1, profit = 2 6 - 1 = 5, min = 1, profit = 6 6 - 1 = 6, min = 1, profit = 5 Profit = 5, at 1 and 6 程式碼 class Solution { public int maxProfit(int[] prices) { int len = prices.length; int min = prices[0]; int profit = 0; for (int i = 0; i \u0026lt; len; i++) { if (prices[i] \u0026lt; min) { min = prices[i]; } if (prices[i] - min \u0026gt; profit) { profit = prices[i] - min; } } return profit; } } ","description":"解題思路 要如何算出最大收益？ 買的價格越低，賣的價格越高。\n但因為買的時間一定要比賣的時間早，所以只能由左至右開始搜尋（index 從 0 開始）\n一開始也只能知道一開始的收益以及目前的金額\n假如給定的價格列表為[7,1,5,3,6,4]\n一開始的收益為 profit = 0\n一開始的金額是 prices [0]\n如果是第一天買股票，第二天賣\n這時候的收益會是 1 - 7 = - 6\n再往後計算的話\n如果是第一天買，第三天賣\n這時候的收益會是 5 - 7 = - 2\n看起來比第一天買第二天賣還要賺（虧比較少）\n但這時發現了一件事，第二天的價格比第一天還要低， 這樣根本不用再去管第一天的價格是多少，因為用第二天的價格 (1) 當買入價來繼續計算， 算出來的收益一定會比用第一天的價格 (7) 當買入價還要划算。 而且時間不能重來。\n因此可以在計算價差時，發現最低價的時候就更新最低價的值， 計算價差的時候就只要用後續的價格 - 最低價即可得到最大收益。\n依照範例給的數據會得到以下結果：\nProfit = price[index] - min 1 - 7 = -6 Min = 1 1 - 1 = 0, min = 1 5 - 1 = 4, min = 1, profit = 0 3 - 1 = 2, min = 1, profit = 2 6 - 1 = 5, min = 1, profit = 6 6 - 1 = 6, min = 1, profit = 5 Profit = 5, at 1 and 6 程式碼 class Solution { public int maxProfit(int[] prices) { int len = prices."},{"id":9,"href":"/Programming/Algorithm/Algs4Princeton/Week1/UnionFind/QuickFind.html","title":"Quick Find","parent":"Union Find","content":" Quick Find Structure 初始資料結構 Find Connected. Union. Implemetion Too slow Cost model Quick-find defect: Union too expensive 參考來源 Quick Find Structure 初始資料結構 名為 id[] 且數量為 N 的陣列\nid[p] 是物件 p 所屬於的 component id\n以上圖為例，id[6] = 0\nFind p 的 id 為？\nConnected. p 跟 q 是否有相同的 id？\nex: id[6] = 0, id[7] =1, 6 跟7 並沒有connect\nUnion. 要將包含 p 跟 q 的兩個components 合併，找出所有id 為 id[p] 的物件， 將其 id 修改成 id[q].\n如上圖，在union 6跟1之後，所有原本 id = id[6] 的id值變為 id[1]\nImplemetion public class QuickUF { private int[] id; public QuickFindUF(int N) { id = new int[N]; for (int i = 0; i \u0026lt; N; i++) { id[i] = i; } } public int find(int p) { return id[p]; } public boolean connected(int p, int q) { return id[p] == id[q]; } public void union(int p, int q) { int pId = id[p]; int qid = id[q]; for (int i = 0; i \u0026lt; id.length; i++) { if (id[i] == pid) { id[i] = qid; } } } } Too slow Cost model Algorithm initialize union Find Quick-find N N 1 Quick-find defect: Union too expensive Ex: 對於N個物件來說，如果有N個Union 指令，那會需要N2次\n因此要想辦法提高Union的效率\n參考來源 [1] Algorithms in Java, Lecture slide\n","description":"Quick Find Structure 初始資料結構 Find Connected. Union. Implemetion Too slow Cost model Quick-find defect: Union too expensive 參考來源 Quick Find Structure 初始資料結構 名為 id[] 且數量為 N 的陣列\nid[p] 是物件 p 所屬於的 component id\n以上圖為例，id[6] = 0\nFind p 的 id 為？\nConnected. p 跟 q 是否有相同的 id？\nex: id[6] = 0, id[7] =1, 6 跟7 並沒有connect\nUnion. 要將包含 p 跟 q 的兩個components 合併，找出所有id 為 id[p] 的物件， 將其 id 修改成 id[q]."},{"id":10,"href":"/Programming/Algorithm/Algs4Princeton/Week2/StackAndQueue/ResizingArrays.html","title":"Resizing Arrays","parent":"Stack And Queue","content":"my solution\n","description":"my solution"},{"id":11,"href":"/Programming/SiteStory/GettingStart.html","title":"Hugo GitHub Page","parent":"Site Story","content":"離安裝好Hugo並胡搞瞎搞也過了大概一週，用我僅存的記憶記錄一下，前面都是湊字數的，重點是最後一段哈哈\n安裝Hugo 主題安裝 Github Page 抓不到css 安裝Hugo 因為我是Mac，所以直接用 brew intstall hugo安裝。\n安裝好之後就可以用 hugo new site blog-test來建立新的網站。\n主題安裝 安裝好Hugo之後，下一步就是挑選主題，我是使用 geekdoc 這個主題，主要是看到他的example site覺得很簡單，剛好我也不想花太多時間在把我的頁面弄的很fancy\n安裝的方法是直接下載他們的release bundle\n// 在themes的folder下面建立hugo-geekdoc的folder mkdir -p themes/hugo-geekdoc/ // 下載 curl -L https://github.com/thegeeklab/hugo-geekdoc/releases/latest/download/hugo-geekdoc.tar.gz | tar -xz -C themes/hugo-geekdoc/ --strip-components=1 安裝好之後再到Hugo的設定檔中把主題設定上去\ntheme = \u0026#34;hugo-geekdoc\u0026#34; 然後啟動Hugo就可以看到預設的頁面了\nhugo server -D 雖然hugo server會自動重build頁面，但是我發現有時候更改檔案內容或是資料夾結構，會無法正確顯示，這時候還是手動重啟hugo server比較穩。 編輯一下就可以用\nhugo 生成靜態內容，會建立一個public的資料夾將你剛剛的文件都放進去。\n然後就可以把他推到github的repository拉\nGithub Page 抓不到css 其實前面的步驟網路上都一堆教學，唯一我遇到的問題就是部署到github page後，發現\n我的css一直跑掉，打開開發工具看一下發現抓不到我的css跟js等檔案。\n在stackoverflow上找了半天，發現是相對路徑的問題，最後在config.toml檔案上加上\nrelativeURLs= true 就解決了。\n","description":"離安裝好Hugo並胡搞瞎搞也過了大概一週，用我僅存的記憶記錄一下，前面都是湊字數的，重點是最後一段哈哈\n安裝Hugo 主題安裝 Github Page 抓不到css 安裝Hugo 因為我是Mac，所以直接用 brew intstall hugo安裝。\n安裝好之後就可以用 hugo new site blog-test來建立新的網站。\n主題安裝 安裝好Hugo之後，下一步就是挑選主題，我是使用 geekdoc 這個主題，主要是看到他的example site覺得很簡單，剛好我也不想花太多時間在把我的頁面弄的很fancy\n安裝的方法是直接下載他們的release bundle\n// 在themes的folder下面建立hugo-geekdoc的folder mkdir -p themes/hugo-geekdoc/ // 下載 curl -L https://github.com/thegeeklab/hugo-geekdoc/releases/latest/download/hugo-geekdoc.tar.gz | tar -xz -C themes/hugo-geekdoc/ --strip-components=1 安裝好之後再到Hugo的設定檔中把主題設定上去\ntheme = \u0026#34;hugo-geekdoc\u0026#34; 然後啟動Hugo就可以看到預設的頁面了\nhugo server -D 雖然hugo server會自動重build頁面，但是我發現有時候更改檔案內容或是資料夾結構，會無法正確顯示，這時候還是手動重啟hugo server比較穩。 編輯一下就可以用\nhugo 生成靜態內容，會建立一個public的資料夾將你剛剛的文件都放進去。\n然後就可以把他推到github的repository拉\nGithub Page 抓不到css 其實前面的步驟網路上都一堆教學，唯一我遇到的問題就是部署到github page後，發現\n我的css一直跑掉，打開開發工具看一下發現抓不到我的css跟js等檔案。\n在stackoverflow上找了半天，發現是相對路徑的問題，最後在config.toml檔案上加上\nrelativeURLs= true 就解決了。"},{"id":12,"href":"/Programming/Algorithm/Algs4Princeton/Week2/ElementSorts.html","title":"Elementary Sorts","parent":"Week 2","content":" ","description":" "},{"id":13,"href":"/Programming/Languages/Java.html","title":"JAVA","parent":"Language","content":"My Java 75 trip\u0026hellip;\nSpring Boot ","description":"My Java 75 trip\u0026hellip;\nSpring Boot "},{"id":14,"href":"/Programming/Algorithm/Grind75/Tree.html","title":"Tree","parent":"Grind 75","content":" Maximum Depth of Binary Tree Maximum Depth of Binary Tree ","description":" Maximum Depth of Binary Tree Maximum Depth of Binary Tree "},{"id":15,"href":"/Programming/Algorithm/Algs4Princeton/Week2.html","title":"Week 2","parent":"Princeton Algorithms","content":" Stack And Queue Stacks Resizing Arrays Elementary Sorts ","description":" Stack And Queue Stacks Resizing Arrays Elementary Sorts "},{"id":16,"href":"/Programming/Algorithm/Grind75/Array/MajorityElement.html","title":"169. Majority Element","parent":"Array","content":"Given an array nums of size n, return the majority element.\nThe majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.\nExample 1:\nInput: nums = [3,2,3] Output: 3 Example 2:\nInput: nums = [2,2,1,1,1,2,2] Output: 2 思路: 用 hashmap 統計每個直出現的次數，最後再找出最大的值\nclass Solution { public int majorityElement(int[] nums) { HashMap\u0026lt;Integer, Integer\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); int len = nums.length; for(int i = 0; i \u0026lt; len; i ++) { if(!hashmap.containsKey(nums[i])) { hashmap.put(nums[i], 1); } else { hashmap.put(nums[i], hashmap.get(nums[i]) + 1); } } int halfLen = len / 2; for (Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : hashmap.entrySet()) { if (entry.getValue() \u0026gt; halfLen) { return entry.getKey(); } } return -1; } } 改寫 在記錄的時候，連帶檢查每個 element出現的次數，只要出現的次數大於 Array 的長度，就可以確定他是這個 Array 的 majority; 一開始放建立 HashMap 時也可以用內建的方法 getOrDefault\nclass Solution { public int majorityElement(int[] nums) { HashMap\u0026lt;Integer, Integer\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); int len = nums.length; for(int i = 0; i \u0026lt; len; i ++) { hashmap.put(nums[i], hashmap.getOrDefault(nums[i], 0) + 1); if (hashmap.get(nums[i]) \u0026gt; len / 2) { return nums[i]; } } return -1; } } ","description":"Given an array nums of size n, return the majority element.\nThe majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.\nExample 1:\nInput: nums = [3,2,3] Output: 3 Example 2:\nInput: nums = [2,2,1,1,1,2,2] Output: 2 思路: 用 hashmap 統計每個直出現的次數，最後再找出最大的值\nclass Solution { public int majorityElement(int[] nums) { HashMap\u0026lt;Integer, Integer\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); int len = nums."},{"id":17,"href":"/Programming/Algorithm/Algs4Princeton/Week1/UnionFind/QuickUnion.html","title":"Quick Union","parent":"Union Find","content":" 初始資料結構 Root Find Union Implement Also too slow Cost model Quick-find defect Quick-union defect 參考來源 因為 Quick-find 演算法中，Union 的效率太低，因此要改善Union，在這章節稱為Quick Union （lazy approach），為什麼要叫Lazy approach呢？因為能躺著就不要做著，能坐著就不要站著，除非死到臨頭不然不要行動。\n初始資料結構 名為 id[] 且數量為 N 的陣列\nid[p] 是物件 p 所屬於的component id\n上面兩個與 Quick-find 一樣，但這次多了一個新的結構， root\nRoot 將一整個Array 看成 a set of trees，也就是說每個物件都屬於一個 tree，這個資料結構就是由很多 tree 集合而成。\n每個物件，會有一個Parent，如下圖，（3 可以接到4，3的 parent 是 4，4 的 parent 是 9) 順著線一直找，當找不到 parent 時，這時候就稱這點為 root\n如果這個物件只有自己，那自己就是root，例如1\nFind 因為每個物件都會有一個 root，要找兩個物件是不是同一個 component 的話，只要看他們的 root 是不是一樣就可以\nUnion 要將兩個物件（例如p, q) 合併，只要將 p 的 root 的 id 變成 q 的root的 id 就可以\n下圖為將9 跟6 合併的例子\n這時候只需要把id[9]改成6 就可以完成合併了\nImplement public class QuickUnionUF { private int[] id; // set id of each object to itself (N array access) public QuickFindUF(int N) { id = new int[N]; for (int i = 0; i \u0026lt; N; i++) { id[i] = i; } } // in the book, this is find in p224 public int root(int i) { while (i != id[i] ) { i = id[i]; } return i; } public boolean connected(int p, int q) { return root[p] == root[q]; } public void union(int p, int q) { int i = root[p]; int j = root[q]; id[i] = j } } Also too slow Cost model Algorithm initialize union Find Quick-find N N 1 Quick-union N N N Quick-find defect Union too expensive： 對於 N 個物件來說，如果有 N 個 Union 指令，那會需要執行 N2 次，因此要想辦法提高 Union 的效率 Quick-union defect Tree can be tall： 導致Find 效率太差 參考來源 [1] Algorithms in Java, Lecture slide\n","description":"初始資料結構 Root Find Union Implement Also too slow Cost model Quick-find defect Quick-union defect 參考來源 因為 Quick-find 演算法中，Union 的效率太低，因此要改善Union，在這章節稱為Quick Union （lazy approach），為什麼要叫Lazy approach呢？因為能躺著就不要做著，能坐著就不要站著，除非死到臨頭不然不要行動。\n初始資料結構 名為 id[] 且數量為 N 的陣列\nid[p] 是物件 p 所屬於的component id\n上面兩個與 Quick-find 一樣，但這次多了一個新的結構， root\nRoot 將一整個Array 看成 a set of trees，也就是說每個物件都屬於一個 tree，這個資料結構就是由很多 tree 集合而成。\n每個物件，會有一個Parent，如下圖，（3 可以接到4，3的 parent 是 4，4 的 parent 是 9) 順著線一直找，當找不到 parent 時，這時候就稱這點為 root\n如果這個物件只有自己，那自己就是root，例如1\nFind 因為每個物件都會有一個 root，要找兩個物件是不是同一個 component 的話，只要看他們的 root 是不是一樣就可以"},{"id":18,"href":"/Programming/SiteStory/GitHubActionWithVPS.html","title":"GitHub Action w/ VPS","parent":"Site Story","content":"","description":""},{"id":19,"href":"/Programming/SiteStory/SSL.html","title":"Install SSL","parent":"Site Story","content":"Domain 是在 namecheap 買的，設定好A紀錄跟CNAME之後就可以用了，再來就是申請SSL憑證 糊裡糊塗就把SSL弄好了，隨手記錄一下印象比較深刻的步驟跟坑。\n領取SSL憑證 收到憑證後 nginx設定 nginx -t 通過但是一直重啟不了nginx 領取SSL憑證 生成私鑰： openssl genrsa -out private.key 2048 生成一個2048位的RSA私鑰，並將其保存在名為 private.key 的文件中。\n接著用剛剛的私鑰生成CSR（證書簽署請求）\nopenssl req -new -key private.key -out csr.csr 會要求提供與SSL證書相關的信息，例如域名、組織名稱、所在地等。請根據提示輸入正確的信息。\nCommon Name (CN)：這邊要填你的域名 domain.com，它後面本來寫說填個名字就好我就傻傻的填我的英文名字，結果一直失敗..\n生成的CSR文件 csr.csr 就可以整個複製上去。 收到憑證後 通常在取得 SSL 憑證時，您會收到兩個檔案：.crt 憑證檔案和 .ca-bundle（或 .bundle）憑證束檔案。\n.crt 憑證檔案是您的 SSL 證書，它包含您的網站的公開金鑰以及其他相關的證書資訊。\n.ca-bundle（或 .bundle）憑證束檔案是根憑證和中繼憑證的集合。它包含了憑證鏈中的所有憑證，用於驗證您的 SSL 憑證的合法性。憑證鏈包括根憑證（Root Certificate）和中繼憑證（Intermediate Certificate）。根憑證是由受信任的憑證授權中心（Certificate Authority）簽署的，而中繼憑證是由根憑證簽署的其他憑證。\n在設定 Nginx 的 SSL 時，需要將 .crt 憑證檔案和 .ca-bundle（或 .bundle）憑證束檔案合併為一個檔案，形成完整的憑證鏈。\n順序不能錯，要先crt再ca-bundle\ncat domain.crt domain.ca-bundle \u0026gt; server.crt nginx設定 # HTTP 重定向到 HTTPS server { listen 80; server_name lazyvic.com; return 301 https://lazyvic.com$request_uri; # 返回 301 重定向到相應的 HTTPS URL } # HTTPS 配置 server { listen 443 ssl; # 監聽 443 端口，啟用 SSL server_name lazyvic.com; ssl_certificate /etc/nginx/ssl/server.crt; # SSL 憑證路徑 ssl_certificate_key /etc/nginx/ssl/private.key; # SSL 憑證私鑰路徑 location / { root /var/www/html/public; # 根目錄，用於存放網站文件 index index.html index.htm; # 默認索引文件 } # 自定義 404 頁面 error_page 404 /404.html; location = /404.html { # 這裡可以指定自定義的 404 頁面的路徑和檔名 } # 自定義 50x 錯誤頁面 error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; # 50x 錯誤頁面的路徑 } } nginx -t 通過但是一直重啟不了nginx 在重啟前有先用 nginx -t 確認無誤，但是重啟nginx卻一直失敗，看了log說是沒有權限取得檔案，查了一下解法如下：\nrestorecon -v -R /etc/nginx 查了一下這個restorecon到底是啥東西\nrestorecon 指令用於恢復檔案和目錄的 SELinux 安全上下文。在某些 Linux 發行版中，如 CentOS 和 RHEL，安全上下文是用於控制檔案和目錄的存取權限和 SELinux 政策的一部分。\n當您遭遇 Nginx SSL 憑證無法載入的問題時，有時是由於 SELinux 安全上下文不正確導致的。透過執行 restorecon 指令，您可以將 /etc/nginx 目錄及其內部的檔案和目錄恢復為預設的 SELinux 安全上下文。\n這樣做可以確保 Nginx 服務以適當的安全上下文執行，並且具有正確的存取權限，從而能夠正確載入並使用 SSL 憑證。\n","description":"Domain 是在 namecheap 買的，設定好A紀錄跟CNAME之後就可以用了，再來就是申請SSL憑證 糊裡糊塗就把SSL弄好了，隨手記錄一下印象比較深刻的步驟跟坑。\n領取SSL憑證 收到憑證後 nginx設定 nginx -t 通過但是一直重啟不了nginx 領取SSL憑證 生成私鑰： openssl genrsa -out private.key 2048 生成一個2048位的RSA私鑰，並將其保存在名為 private.key 的文件中。\n接著用剛剛的私鑰生成CSR（證書簽署請求）\nopenssl req -new -key private.key -out csr.csr 會要求提供與SSL證書相關的信息，例如域名、組織名稱、所在地等。請根據提示輸入正確的信息。\nCommon Name (CN)：這邊要填你的域名 domain.com，它後面本來寫說填個名字就好我就傻傻的填我的英文名字，結果一直失敗..\n生成的CSR文件 csr.csr 就可以整個複製上去。 收到憑證後 通常在取得 SSL 憑證時，您會收到兩個檔案：.crt 憑證檔案和 .ca-bundle（或 .bundle）憑證束檔案。\n.crt 憑證檔案是您的 SSL 證書，它包含您的網站的公開金鑰以及其他相關的證書資訊。\n.ca-bundle（或 .bundle）憑證束檔案是根憑證和中繼憑證的集合。它包含了憑證鏈中的所有憑證，用於驗證您的 SSL 憑證的合法性。憑證鏈包括根憑證（Root Certificate）和中繼憑證（Intermediate Certificate）。根憑證是由受信任的憑證授權中心（Certificate Authority）簽署的，而中繼憑證是由根憑證簽署的其他憑證。\n在設定 Nginx 的 SSL 時，需要將 .crt 憑證檔案和 .ca-bundle（或 .bundle）憑證束檔案合併為一個檔案，形成完整的憑證鏈。\n順序不能錯，要先crt再ca-bundle\ncat domain.crt domain.ca-bundle \u0026gt; server.crt nginx設定 # HTTP 重定向到 HTTPS server { listen 80; server_name lazyvic."},{"id":20,"href":"/Programming/Algorithm/Grind75/Array/InsertInterval.html","title":"57. Insert Interval","parent":"Array","content":"You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\nReturn intervals after the insertion.\nExample 1:\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Example 2:\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. 解題思路 建立一個新的ArrayList ans\n把這個題目用數線來思考，從左邊開始檢查。對 newInterval[0] 以及 intervals[[i][0]] 比較，若是 newInterval[0] 較大，就把intervals[i] 加到 ans 內，因為代表 newInterval 的起始點會再加入的這些數線的起始點之後。\n處理 edge case:\n如果巡過一輪，發現 ans是空的，代表新的數線最小值是最小的。直接把數線加進去\n新的數線的最小值比所有數線的最小值大，這時候直接把 newInterval 加進去。ex intervals = [ [1,3], [4 ,5] ], newInterval = [6, 7], ans = [[1,3], [4 , 5], [6,7]]\n處理最大值：加完之後將當下ans的最大值與最新數線的最大值比較後取最大的\n比較剩下的數線，若剩下的束線最小值小於目前數線的最小值，檢查兩者的最大值後取最大的\n將剩下的數線加入ans內\nans ArrayList轉換為2D陣列\nclass Solution { public int[][] insert(int[][] intervals, int[] newInterval) { ArrayList\u0026lt;int[]\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); int len = intervals.length; int i = 0; while (i \u0026lt; len \u0026amp;\u0026amp; intervals[i][0] \u0026lt;newInterval[0]) { ans.add(intervals[i]); i++; } //edge case if (ans.size() == 0 || newInterval[0] \u0026gt; ans.get(ans.size() - 1)[1]) { ans.add(newInterval); } else { int[] lastInterval = ans.get(ans.size() - 1); lastInterval[1] = Math.max(lastInterval[1], newInterval[1]); } // compare right side of line(interval while (i \u0026lt; len) { int[] lastInterval = ans.get(ans.size() - 1); if (lastInterval[1] \u0026gt;= intervals[i][0]) { lastInterval[1] = Math.max(lastInterval[1], intervals[i][1]); } else{ // If the last interval does not overlap with the current interval, add it to the answer list ans.add(intervals[i]); } i++; } return ans.toArray(new int[ans.size()][]); } } ","description":"You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary)."},{"id":21,"href":"/Programming/Algorithm/Grind75/Array/Contains-Duplicate.html","title":"217. Contains Duplicate","parent":"Array","content":"Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\nExample 1:\nInput: nums = [1,2,3,1] Output: true Example 2:\nInput: nums = [1,2,3,4] Output: false Example 3:\nInput: nums = [1,1,1,3,3,4,3,2,4,2] Output: true 解題思路 一樣用hash map 統計有無重複出現的\nclass Solution { public boolean containsDuplicate(int[] nums) { HashMap\u0026lt;Integer, Integer\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); int len = nums.length; for(int i = 0; i \u0026lt; len; i ++) { hashmap.put(nums[i], hashmap.getOrDefault(nums[i], 0) + 1); if (hashmap.get(nums[i]) \u0026gt; 1) { return true; } } return false; } } ","description":"Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\nExample 1:\nInput: nums = [1,2,3,1] Output: true Example 2:\nInput: nums = [1,2,3,4] Output: false Example 3:\nInput: nums = [1,1,1,3,3,4,3,2,4,2] Output: true 解題思路 一樣用hash map 統計有無重複出現的\nclass Solution { public boolean containsDuplicate(int[] nums) { HashMap\u0026lt;Integer, Integer\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); int len = nums."},{"id":22,"href":"/Programming/Algorithm/Algs4Princeton/Week1/UnionFind/WeithgedQuickUnion.html","title":"Weighted Quick Union","parent":"Union Find","content":" Imporvement 1: weighting Data Structure Find Union Implement Weighted quick-union analysis Running time. Proposition Can we impove it even further? 參考來源 How to imporvements Quick-union?\n上一篇中， Quick-Union 演算法中，最後可能因為每個tree長得太高，導致效率變差。\nImporvement 1: weighting 在每次 Union 時，順帶記錄每棵樹的 size (number of objects)\n在每次 Union 時，刻意將較小的樹連接到較大的樹下\nData Structure 與 quick-union 一樣，但多追蹤每棵樹的大小 (size of objects for roots)\nFind 與 quick-union 一樣\nUnion 修改為：\n將小的樹往大的樹接 更新 sz[] array Implement public class QuickUnionUF { private int[] id; private int[] sz; // size of objects for roots (site indexed) // set id of each object to itself (N array access) public WeightedQuickFindUF(int N) { id = new int[N]; for (int i = 0; i \u0026lt; N; i++) { id[i] = i; } // init sz of every objects sz = new int[N]; for (int i = 0; i \u0026lt; N; i++) { sz[i] = 1; } } public int root(int i) { while (i != id[i] ) { i = id[i]; } return i; } public boolean connected(int p, int q) { return root[p] == root[q]; } public void union(int p, int q) { int i = root[p]; int j = root[q]; if (i == j) { return; } if (sz[i] \u0026lt; sz[j]) { id[i] = j; sz[j] += sz[i]; } else { id[j] = i; sz[i] += sz[j]; } id[i] = j } } Weighted quick-union analysis Running time. Find: takes time proportional to depth of p and q. Union: takes constant time, given roots. Proposition Depth of any node x is at most lg N (log- base-2 logarithm).\n這裡一開始比較難以理解，教授的原話如下\nSo, when the depth of x increases, the size of its tree at least doubles. So, that\u0026rsquo;s the key because that means that the size of the tree containing x can double at most log N times because if you start with one and double log N times, you get N and there\u0026rsquo;s only N nodes in the tree.\n看了書之後我的理解是：\nMaximum height of a tree only increases when 2 trees with same height are merged.\nYou can make maximum logN merges of such trees. (as you will have to keep dividing N with 2 to form i amount of such trees. At the example with N=8 below, you create equally sized trees to merge max 3 times.\nTherefore, depth of any node x is at most LogN. (due to max height)\n假設N是8，每次union後會多一層，每個樹的 objects 數量最多變兩倍，這樣一來對任何一顆樹而言 union 到最後最多只有三層. (log8)，因此對有 N個 object 的集合來說，每一顆 node的深度最多就是 logN。可以大幅減少每個 node 的 depth。\nAlgorithm initialize union Find Quick-find N N 1 Quick-union N N N Withgted QU N lg N Lg N Can we impove it even further? 其實是可以的，而且只要多一行code。\n概念是：每次在尋找root的時候，將找到的 children node 都連向 root，這樣可以使得最後的樹趨近於平整\npublic int root(int i) { while (i != id[i] ) { id[i] = id[id[i]] // one more line of code i = id[i]; } return i; } 參考來源 [1] Algorithms in Java, Lecture slide\n","description":"Imporvement 1: weighting Data Structure Find Union Implement Weighted quick-union analysis Running time. Proposition Can we impove it even further? 參考來源 How to imporvements Quick-union?\n上一篇中， Quick-Union 演算法中，最後可能因為每個tree長得太高，導致效率變差。\nImporvement 1: weighting 在每次 Union 時，順帶記錄每棵樹的 size (number of objects)\n在每次 Union 時，刻意將較小的樹連接到較大的樹下\nData Structure 與 quick-union 一樣，但多追蹤每棵樹的大小 (size of objects for roots)\nFind 與 quick-union 一樣\nUnion 修改為：\n將小的樹往大的樹接 更新 sz[] array Implement public class QuickUnionUF { private int[] id; private int[] sz; // size of objects for roots (site indexed) // set id of each object to itself (N array access) public WeightedQuickFindUF(int N) { id = new int[N]; for (int i = 0; i \u0026lt; N; i++) { id[i] = i; } // init sz of every objects sz = new int[N]; for (int i = 0; i \u0026lt; N; i++) { sz[i] = 1; } } public int root(int i) { while (i !"},{"id":23,"href":"/Programming/SiteStory/TyporaUpic.html","title":"Typora + Upic","parent":"Site Story","content":"Hugo是用MarkDown來編輯文件的，這時候有個好用的MarkDown 編輯器就很好用，最後我是選擇用Typroa來編輯文件，再貼到Hugo發布，會選擇Typora的原因是因為Typora支援自動上傳圖片並產生連結功能，非常適合Lazy的我。 簡單記錄一下如何用uPic自動上傳圖片到我的GitHub\nGitHub開一個新的Repo並產生token uPic 安裝uPic 配置 Typora設定 GitHub開一個新的Repo並產生token 在GitHub首頁-\u0026gt;setting-\u0026gt;Developer Setting-\u0026gt; Personal Ascess Token裡面產生一組新的Token。\n我是選classic的token，因為看到另一個還在beta。\n可以只勾public_repo，剩下我都沒勾，Note隨便打就好。\nuPic 安裝uPic brew install bigwig-club/brew/upic --cask 配置 安裝好之後打開uPic，是Mac的話會在最上面那一條出現，一開始沒注意到還一直想說怎麼打不開\u0026hellip;\n進入設定頁面\nOwner -\u0026gt; 你的github帳號 Repo -\u0026gt; 你的repo Token-\u0026gt; GitHub token 然後可以按下驗證聽說會有成功畫面出現，但我按了都沒反應就是了。最後是去Typora那邊測試可不可以成功\n設定好後再把uPic預設上傳方式改成GitHub即可\nTypora設定 照著設定按一下test Uploader顯示成功，之後圖片拖進來就會自動寫好Markdown嚕。\n","description":"Hugo是用MarkDown來編輯文件的，這時候有個好用的MarkDown 編輯器就很好用，最後我是選擇用Typroa來編輯文件，再貼到Hugo發布，會選擇Typora的原因是因為Typora支援自動上傳圖片並產生連結功能，非常適合Lazy的我。 簡單記錄一下如何用uPic自動上傳圖片到我的GitHub\nGitHub開一個新的Repo並產生token uPic 安裝uPic 配置 Typora設定 GitHub開一個新的Repo並產生token 在GitHub首頁-\u0026gt;setting-\u0026gt;Developer Setting-\u0026gt; Personal Ascess Token裡面產生一組新的Token。\n我是選classic的token，因為看到另一個還在beta。\n可以只勾public_repo，剩下我都沒勾，Note隨便打就好。\nuPic 安裝uPic brew install bigwig-club/brew/upic --cask 配置 安裝好之後打開uPic，是Mac的話會在最上面那一條出現，一開始沒注意到還一直想說怎麼打不開\u0026hellip;\n進入設定頁面\nOwner -\u0026gt; 你的github帳號 Repo -\u0026gt; 你的repo Token-\u0026gt; GitHub token 然後可以按下驗證聽說會有成功畫面出現，但我按了都沒反應就是了。最後是去Typora那邊測試可不可以成功\n設定好後再把uPic預設上傳方式改成GitHub即可\nTypora設定 照著設定按一下test Uploader顯示成功，之後圖片拖進來就會自動寫好Markdown嚕。"},{"id":24,"href":"/Programming/Algorithm/Grind75/Array/ThreeSum.html","title":"15. Three Sum","parent":"Array","content":"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\nExample 1:\nInput: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0. nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0. The distinct triplets are [-1,0,1] and [-1,-1,2]. Notice that the order of the output and the order of the triplets does not matter. Example 2:\nInput: nums = [0,1,1] Output: [] Explanation: The only possible triplet does not sum up to 0. Example 3:\nInput: nums = [0,0,0] Output: [[0,0,0]] Explanation: The only possible triplet sums up to 0. 解題思路 如果有做過Two Sum跟 Two Sum 2的話，這一題是非常直覺的\n但我沒做過Two Sum 2，也不覺得直覺，更知道一定不可能是3個for loop。直到看到\nA + B + C = 0\n就等於是Two Sum 的題目，target = -C, 找出A,B\n所以一樣可以用HashMap來做這一題，但是這次學了不同的方法，用 Left, Right point來實作\nclass Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); // 因為要用左右指針，所以先將原來的Array排序 Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length; i++) { int a = nums[i]; // 因為不能出現重複的Array，如果 a 右邊的下一個數字與a相同，直接跳過 if (i \u0026gt; 0 \u0026amp;\u0026amp; a == nums[i - 1]) { continue; } // 定義左右指針 int l = i + 1; int r = nums.length - 1; // 在左指針超過右指針前，瘋狂迴圈 while (l \u0026lt; r) { int threeSum = nums[l] + nums[r] + a; // 如果加起來的結果大於0，代表右邊的數字太大了，將右指針 -1 if (threeSum \u0026gt; 0) { r --; // 如果加起來的結果小於0，代表左邊的數字太小了，將左指針 +1 } else if (threeSum \u0026lt; 0) { l ++; } else { // 等於0，找到一組，加進ArrayList內 res.add(Arrays.asList(a, nums[l], nums[r])); // 左指針加一，重新開始找下一個組合 // 但為了減少不必要的查找，如果左指針 +1 後跟上次一樣，就再 +1 l++; while (nums[l] == nums[l - 1] \u0026amp;\u0026amp; l \u0026lt; r) { l++; } // 右指針則是相反（但其實可以忽略右指針，只換左指針也可以） r--; while (nums[r] == nums[r + 1] \u0026amp;\u0026amp; l \u0026lt; r) { r--; } } } } return res; } } ","description":"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\nExample 1:\nInput: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0."},{"id":25,"href":"/Programming/Algorithm/Grind75/Array/ProductOfArrayExceptSelf.html","title":"238. Product of Array Except Self ","parent":"Array","content":"Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in O(n) time and without using the division operation.\nExample 1:\nInput: nums = [1,2,3,4] Output: [24,12,8,6] Example 2:\nInput: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] 解題思路 個人解 一開始想到，那我不就全部先乘起來，遇到每個值之後用成起來的結果除以自身就可以得到答案，但太天真了，忘了自己是 0 的狀況。\n後來處理了自己是 0 的狀況之後，因為預設乘積是 1，處理不到全部都是 0 的狀況。\n全部是0 的狀況處理完之後，又沒處理到 0 的個數 \u0026gt; 2的狀況\n最後處理完之後發現，基本上超過2個0，回傳的答案就會全部是 0\n經過一堆 fail submit之後 總算 pass 了\nclass Solution { public int[] productExceptSelf(int[] nums) { int product = 1; int zeroCount = 0; int[] result = new int[nums.length]; // Calculate the product of all elements except zeros. for (int num : nums) { if (num != 0) { product *= num; } else { zeroCount++; } } // Fill the result array. for (int i = 0; i \u0026lt; nums.length; i++) { if (zeroCount \u0026gt; 1) { result[i] = 0; } else if (zeroCount == 1) { result[i] = nums[i] == 0 ? product : 0; } else { result[i] = product / nums[i]; } } return result; } } 其他解 網路通常都是用這種解法，比較單純，但我一開始想不到，第二次回來做也還是忘了\u0026hellip;\n是先把這個數左邊的乘積記錄下來，再把右邊的乘積記錄下來，產生兩個 Array (要一個也可以)\n最後在把這兩個 Array 對應的 index 乘起來就是答案。\nclass Solution { public int[] productExceptSelf(int[] nums) { int n = nums.length; int[] prefixProducts = new int[n]; int[] suffixProducts = new int[n]; int[] result = new int[n]; // Calculate prefix products int prefix = 1; for (int i = 0; i \u0026lt; n; i++) { prefixProducts[i] = prefix; prefix *= nums[i]; } // Calculate suffix products int suffix = 1; for (int i = n - 1; i \u0026gt;= 0; i--) { suffixProducts[i] = suffix; suffix *= nums[i]; } // Calculate the result array by combining prefix and suffix products for (int i = 0; i \u0026lt; n; i++) { result[i] = prefixProducts[i] * suffixProducts[i]; } return result; } } ","description":"Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in O(n) time and without using the division operation.\nExample 1:\nInput: nums = [1,2,3,4] Output: [24,12,8,6] Example 2:\nInput: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] 解題思路 個人解 一開始想到，那我不就全部先乘起來，遇到每個值之後用成起來的結果除以自身就可以得到答案，但太天真了，忘了自己是 0 的狀況。"},{"id":26,"href":"/Programming/Algorithm/Grind75/Array/CombinationSum.html","title":"39. Combination Sum ","parent":"Array","content":"Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the\nfrequency\nof at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\nExample 1:\nInput: candidates = [2,3,6,7], target = 7 Output: [[2,2,3],[7]] Explanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times. 7 is a candidate, and 7 = 7. These are the only two combinations. Example 2:\nInput: candidates = [2,3,5], target = 8 Output: [[2,2,2,2],[2,3,3],[3,5]] Example 3:\nInput: candidates = [2], target = 1 Output: [] 知識點 如果題目要求我們去排列 (Permutations) 或組合 (Combinations) 的時候，通常可以用 Back Tracking 的方法來處理。 Back Tracking 的基本架構是： Base Case（基本情況）： 在遞迴函式開始處，檢查是否已經達到了終止條件，這被稱為基本情況。如果終止條件成立，那麼這是遞迴的終止點，你可以在這裡處理結果並返回。這是遞迴的基礎。 Iterate Input（遍歷輸入）： 遍歷題目給出的輸入，這通常是一個列表、陣列或其他類型的集合。在每一個迴圈中，選擇其中的一個元素，然後對其進行相應的操作。這個迴圈允許你嘗試所有可能的選擇。 Call Recursive（遞迴呼叫）： 在迴圈中，對於每個元素，你都會進行遞迴呼叫。這就是“深入”問題的一部分。將更新後的狀態（可能是已經選擇的元素、新的索引等）傳遞給遞迴函式。在不同的狀態下進一步處理問題。 Restore/Update State（回復/更新狀態）： 在每個遞迴返回後，你都需要確保狀態的一致性。如果在遞迴過程中進行了狀態的修改，則需要恢復到遞迴前的狀態（回復狀態）。如果在遞迴過程中加入了新的選擇，則需要將其刪除，以確保下一輪迴圈可以嘗試其他選擇（更新狀態）。 def backtrack(result, state, choices, parameters): if termination_condition_is_met: process_result return for choice in choices: if choice meets conditions: update_state backtrack(result, new_state, choices, new_parameters) restore_state 本題情況 Base Case： 用減法的話 target - list 的 sum =0 || \u0026lt; 0 都是 base case Iterate Input / Call Recursive： 建立一個 tmpList 將元素一個一個加進去後檢查 target 剩下多少 Restore/Update State： 如果遇上 base case的話，return 掉，並將 tmpList 最後一位pop掉 Recursive(input, [], 7, 0); Recursive(input, [2], 7-5, 0); Recursive(input, [2, 2], 5-2, 0); Recursive(input, [2, 2, 2], 3-2, 0); Recursive(input, [2, 2, 2, 2], 1-2, 0); //return and pop last item in tmpList, enter in next for loop Recursive(input, [2, 2, 2, 3], 1-3, 1); //return and pop last item in tmpList, enter in next for loop Recursive(input, [2, 2, 2, 6], 1-5, 2); //return and pop last item in tmpList, enter in next for loop Recursive(input, [2, 2, 2, 7], 1-7, 3); //return and pop last item in tmpList, enter in next for loop // end for loop // pop last item in tmpList Recursive(input, [2, 2, 2], 3-2, 0); pop last item in tmpList, enter in next for loop Recursive(input, [2, 2, 3], 3-3, 1); pop last item in tmpList, enter in next for loop, add to result Recursive(input, [2, 2, 6], 3-6, 2); pop last item in tmpList, enter in next for loop Recursive(input, [2, 2, 7], 3-7, 2); pop last item in tmpList, enter in next for loop // end for loop // pop last item in tmpList Recursive(input, [2, 2], 5-2, 0); pop last item in tmpList, enter in next for loop Recursive(input, [2, 3], 5-3, 1) ... Java Implement class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); backtrack(result, new ArrayList\u0026lt;\u0026gt;(), candidates, target, 0); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; tmpList, int[] candidates, int remain, int index){ if (remain \u0026lt; 0) { return; } if (remain == 0) { result.add(new ArrayList\u0026lt;\u0026gt;(tmpList)); return; } for (int i = index; i \u0026lt; candidates.length; i++) { int newRemain = remain - candidates[i]; tmpList.add(candidates[i]); backtrack(result, tmpList, candidates, newRemain, i); tmpList.remove(tmpList.size() - 1); } } } ","description":"Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the\nfrequency\nof at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."},{"id":27,"href":"/Programming/Languages/Miscellaneous/cipher.html","title":"Chpher","parent":"Miscellaneous","content":" Decrypt AES-GCM encoded content with JAVA Cipher using PHP OpenSSL ","description":" Decrypt AES-GCM encoded content with JAVA Cipher using PHP OpenSSL "},{"id":28,"href":"/Programming/Algorithm/Grind75.html","title":"Grind 75","parent":"Algorithm","content":" List of Grind 75 Array 1. Two Sum 121. Best Time to Buy and Sell Stock 169. Majority Element 217. Contains Duplicate 57. Insert Interval 15. Three Sum 238. Product of Array Except Self 39. Combination Sum Tree Maximum Depth of Binary Tree Maximum Depth of Binary Tree ","description":" List of Grind 75 Array 1. Two Sum 121. Best Time to Buy and Sell Stock 169. Majority Element 217. Contains Duplicate 57. Insert Interval 15. Three Sum 238. Product of Array Except Self 39. Combination Sum Tree Maximum Depth of Binary Tree Maximum Depth of Binary Tree "},{"id":29,"href":"/Programming/Languages/Java/Spring-Boot/Getting-started-with-Spring/test.html","title":"Level 1.3","parent":"Getting Started With Spring","content":"Nested folder test\nLevel 1.3.1 ","description":"Nested folder test\nLevel 1.3.1 "},{"id":30,"href":"/Programming/Languages/Java/Spring-Boot/Getting-started-with-Spring/test/two-sum.html","title":"Level 1.3.1","parent":"Level 1.3","content":"Level 1.3.1\n","description":"Level 1.3.1"},{"id":31,"href":"/Programming/Languages/Miscellaneous.html","title":"Miscellaneous","parent":"Language","content":"Jotting the various pitfalls and challenges i encountered\nChpher ","description":"Jotting the various pitfalls and challenges i encountered\nChpher "},{"id":32,"href":"/Programming/Languages/PHP/PhpUnit.html","title":"PHP UNIT","parent":"PHP","content":"My leetcode blind 75 trip\u0026hellip;\nBasic Setting ","description":"My leetcode blind 75 trip\u0026hellip;\nBasic Setting "},{"id":33,"href":"/Programming/SiteStory.html","title":"Site Story","parent":"Programming","content":" Why Hugo Hugo GitHub Page GitHub Action w/ VPS Install SSL Typora \u0026#43; Upic ","description":" Why Hugo Hugo GitHub Page GitHub Action w/ VPS Install SSL Typora \u0026#43; Upic "},{"id":34,"href":"/Programming/Languages/Java/Spring-Boot.html","title":"Spring Boot","parent":"JAVA","content":"My leetcode blind 75 trip\u0026hellip;\nGetting Started With Spring Spring 2 Start Level 1.3 Level 1.3.1 Integrated Spring Integrate Spring 1 Integrate Spring 2 ","description":"My leetcode blind 75 trip\u0026hellip;\nGetting Started With Spring Spring 2 Start Level 1.3 Level 1.3.1 Integrated Spring Integrate Spring 1 Integrate Spring 2 "},{"id":35,"href":"/tags/array.html","title":"array","parent":"Tags","content":"","description":""},{"id":36,"href":"/tags/backtrack.html","title":"backtrack","parent":"Tags","content":"","description":""},{"id":37,"href":"/tags/java.html","title":"java","parent":"Tags","content":"","description":""},{"id":38,"href":"/tags/leetcode.html","title":"leetcode","parent":"Tags","content":"","description":""},{"id":39,"href":"/tags/recursive.html","title":"recursive","parent":"Tags","content":"","description":""},{"id":40,"href":"/tags.html","title":"Tags","parent":"","content":"","description":""},{"id":41,"href":"/Programming/Languages/PHP/PhpUnit/BasicSetting.html","title":"Basic Setting","parent":"PHP UNIT","content":" PHPUnit 安裝 建立設定檔 phpunit.xml 一次執行所有test phpunit.xml 常用參數 The bootstrap Attribute The cacheDirectory Attribute The cacheResult Attribute The colors Attribute PHPUnit 安裝 composer require --dev phpunit/phpunit 安裝完之後就可以執行測試\nphp vendor/bin/phpunit yourTest.php 建立設定檔 phpunit.xml 一次執行所有test 建立一個 phpunit.xml檔案，並在裡面指定路徑，之後這個folder裡面所有的測試就會被執行\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;phpunit bootstrap=\u0026#34;bootstrap.php\u0026#34; colors=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;testsuites\u0026gt; \u0026lt;testsuite name=\u0026#34;All Tests\u0026#34;\u0026gt; \u0026lt;directory\u0026gt;tests\u0026lt;/directory\u0026gt; \u0026lt;/testsuite\u0026gt; \u0026lt;/testsuites\u0026gt; \u0026lt;/phpunit\u0026gt; 之後這個 folder 裡面所有的測試就會被執行 (測試的檔名要是Test 結尾，測試的method 要是 test 開頭)\nappTest.php\n\u0026lt;?php class appTest extends TestCase { public function testSomething() { assertTrue(true); } } php vendor/bin/phpunit phpunit.xml 常用參數 The bootstrap Attribute This attribute configures the bootstrap script that is loaded before the tests are executed. This script usually only registers the autoloader callback that is used to load the code under test.\nThe cacheDirectory Attribute This attribute configures the directory in which PHPUnit caches information such as test results (see below) or the result of static code analysis that is performed for code coverage reporting.\nThe cacheResult Attribute Possible values: true or false (default: true)\nThis attribute configures the caching of test results. This caching is required for ordering tests by defects or duration with the executionOrder attribute (see The executionOrder Attribute).\nThe colors Attribute Possible values: true or false (default: false)\nThis attribute configures whether colors are used in PHPUnit’s output.\nSetting this attribute to true is equivalent to using the --colors=auto CLI option.\nSetting this attribute to false is equivalent to using the --colors=never CLI option.\n","description":"PHPUnit 安裝 建立設定檔 phpunit.xml 一次執行所有test phpunit.xml 常用參數 The bootstrap Attribute The cacheDirectory Attribute The cacheResult Attribute The colors Attribute PHPUnit 安裝 composer require --dev phpunit/phpunit 安裝完之後就可以執行測試\nphp vendor/bin/phpunit yourTest.php 建立設定檔 phpunit.xml 一次執行所有test 建立一個 phpunit.xml檔案，並在裡面指定路徑，之後這個folder裡面所有的測試就會被執行\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;phpunit bootstrap=\u0026#34;bootstrap.php\u0026#34; colors=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;testsuites\u0026gt; \u0026lt;testsuite name=\u0026#34;All Tests\u0026#34;\u0026gt; \u0026lt;directory\u0026gt;tests\u0026lt;/directory\u0026gt; \u0026lt;/testsuite\u0026gt; \u0026lt;/testsuites\u0026gt; \u0026lt;/phpunit\u0026gt; 之後這個 folder 裡面所有的測試就會被執行 (測試的檔名要是Test 結尾，測試的method 要是 test 開頭)\nappTest.php\n\u0026lt;?php class appTest extends TestCase { public function testSomething() { assertTrue(true); } } php vendor/bin/phpunit phpunit."},{"id":42,"href":"/tags/php.html","title":"php","parent":"Tags","content":"","description":""},{"id":43,"href":"/tags/unittest.html","title":"unittest","parent":"Tags","content":"","description":""},{"id":44,"href":"/tags/Algorithm.html","title":"Algorithm","parent":"Tags","content":"","description":""},{"id":45,"href":"/tags/cipher.html","title":"cipher","parent":"Tags","content":"","description":""},{"id":46,"href":"/Programming/Languages/Miscellaneous/cipher/Decrypt-AES-GCM-encoded-content-with-JAVA-Cipher-using-PHP-OpenSSL.html","title":"Decrypt AES-GCM encoded content with JAVA Cipher using PHP OpenSSL","parent":"Chpher","content":" Conclusion The Process 參考資料 最近工作遇到一個專案，是要把透過Java使用AES-GCM加密過的資料解密，因為對方也沒有講清楚（或是不熟）導致解密有點不順利，不過後來還是成功解出來了，因此紀錄一下。\nIn a recent project, I had to decrypt data encrypted using AES-GCM in Java. Despite some initial challenges due to unclear instructions or lack of familiarity, I eventually succeeded in decrypting the data. Here\u0026rsquo;s a brief summary of the process.\nConclusion Java透過AES-GCM加密後的結果會包含兩部分：加密後字串+Tag，要解密時把字串拆開拿到Tag，並且只對加密後字串解密。\nwhen encrypting data using AES-GCM in Java, the resulting ciphertext will consist of two parts: the encrypted string and the tag. When decrypting, it is important to separate the ciphertext and retrieve the tag. The decryption process should only be applied to the encrypted string part.\nThe Process Given data:\nCipher: AES-GCM Key: i_am_key (to be hashed using SHA-256) IV: 6732ebbdb62d93067ad6aad8 (hex) encryptedText: e8675abcd27f9b2b734504cb8adfbd88d8592c25960e8e7d4df060 plainText: \u0026lsquo;hello world\u0026rsquo; 一開始只有這些資訊，因此我直接先試試看，因為有特地提到 key 要 sha256 hash，因此我判斷是用AES-256-GCM算法\nWith the initial information provided, I proceeded with the decryption attempt. Since it was specifically mentioned that the key needed to be hashed using SHA-256, I determined that the AES-256-GCM algorithm was being used.\npublic function testDecrypt() { $plainText = \u0026#39;hello world\u0026#39;; $cipher = \u0026#39;AES-256-GCM\u0026#39;; $key = \u0026#39;i_am_key\u0026#39;; $key = hash(\u0026#39;sha256\u0026#39;, $key, true); $iv = \u0026#39;6732ebbdb62d93067ad6aad8\u0026#39;; $iv = hex2bin($iv); $encryptedText = \u0026#39;e8675abcd27f9b2b734504cb8adfbd88d8592c25960e8e7d4df060\u0026#39;; $encryptedBindToken = hex2bin(substr($encryptedText, 0, -$tagLength)); $tag = hex2bin(substr($encryptedText, -$tagLength)); $decrypted = openssl_decrypt(bin2hex($encryptedText), $cipher, $key, OPENSSL_RAW_DATA , $iv); $this-\u0026gt;assertEquals($decrypted, $plainText); } Get false directly, unexpectedly.\nPHPUnit 9.6.9 by Sebastian Bergmann and contributors. Time: 00:00.060, Memory: 6.00 MB There was 1 failure: 1) xxxTest::testDecrypt Failed asserting that \u0026#39;hello world\u0026#39; matches expected false. FAILURES! 因此便去查一下資料，發現透過AES-GCM加密後會有一個 Tag 值，這個值也是解密會用到的\nTherefore, I proceeded to look up the information and found that when using AES-GCM encryption, there is a tag value generated, which is also used during the decryption process.\nThe GCM document from NIST (National Institute of Standards and Technology)\nThe following two bit strings comprise the output data of the authenticated encryption function:\n• A ciphertext, denoted C, whose bit length is the same as that of the plaintext.\n• An authentication tag, or tag, for short, denoted T.\n下面這個RFC也有提到會有一個 \u0026ldquo;Tag\u0026rdquo;\nThe RFC, also mentions the presence of a \u0026ldquo;Tag\u0026rdquo;\nAES-GCM has four inputs: an AES key, an initialization vector (IV), a plaintext content, and optional additional authenticated data (AAD).\nAES-GCM generates two outputs: a ciphertext and message authentication code (also called an authentication tag).\n但是我並沒有這個 \u0026ldquo;Tag\u0026rdquo;，客戶也沒提供，因此後來又去查一下資料，看看有沒有辦法透過已經有的資料推出Tag，後來被我查到了，Tag就在加密後字串的最後面(至少用Java加密後的是這樣)\nHowever, I did not have this \u0026ldquo;Tag\u0026rdquo; and the client did not provide it either. So I further researched and tried to find a way to derive the Tag using the available data. Eventually, I found it! The Tag is located at the end of the encrypted string (at least for Java).\nIn Java the tag is unfortunately added at the end of the ciphertext. - StackOverFlow\n所以客戶提供的字串會有一段是tag，但目前還是不知道長度是多少，本來想直接問一下他們tag長度設定多少，但還是算了，先試試看預設長度 128bits。\nSo the string provided contains a section that represents the tag. However, the length of the tag is still unknown. Initially, I thought about directly asking for the tag length, but I decided to try it using the default length of 128 bits.\n因為提供的hex的加密字串，所以直接取的話要算32個字元，如果轉成binary，只要取16個字元就好，這邊就直接抓最後32字元\nSince the provided encrypted string is in hexadecimal format, if we consider each hex digit as one character, it would require 32 characters. However, if we convert it to binary format, we only need 16 characters. Therefore, I will directly extract the last 32 characters as the tag.\npublic function testDecrypt() { $plainText = \u0026#39;hello world\u0026#39;; $cipher = \u0026#39;AES-256-GCM\u0026#39;; $key = \u0026#39;i_am_key\u0026#39;; $key = hash(\u0026#39;sha256\u0026#39;, $key, true); $iv = \u0026#39;6732ebbdb62d93067ad6aad8\u0026#39;; $iv = hex2bin($iv); $encryptedText = \u0026#39;e8675abcd27f9b2b734504cb8adfbd88d8592c25960e8e7d4df060\u0026#39;; $tagLength = 32; $tag = hex2bin(substr($encryptedText, -$tagLength)); $decrypted = openssl_decrypt(bin2hex($encryptedText), $cipher, $key, OPENSSL_RAW_DATA , $iv, $tag); $this-\u0026gt;assertEquals($decrypted, $plainText); } PHPUnit 9.6.9 by Sebastian Bergmann and contributors. Time: 00:00.060, Memory: 6.00 MB There was 1 failure: 1) xxxTest::testDecrypt Failed asserting that \u0026#39;hello world\u0026#39; matches expected false. FAILURES! 結果還是 false，不知道是哪邊弄錯了，難道是tag長度弄錯了?!\nThe result still turned out to be \u0026ldquo;false,\u0026rdquo; and I\u0026rsquo;m not sure where the mistake lies. Could it be that the tag length was set incorrectly?!\n但後來想到既然沒提供 Tag 的話，代表他們八成也是用預設長度（後來證明沒錯，測了幾個長度的 tag 也是失敗）\nHowever, later on, I realized that if they didn\u0026rsquo;t provide the tag, it probably means they also used the default length (which was later confirmed to be true as testing different tag lengths also failed).\n最後真的沒辦法了，自己用 key 跟 iv 加密一次看一下結果如何\nIn the end, when all else failed, I decided to encrypt it myself using the key and IV and see what the result would be.\npublic function testEncrypt() { $plainText = \u0026#39;hello world\u0026#39;; $cipher = \u0026#39;AES-256-GCM\u0026#39;; $key = \u0026#39;i_am_key\u0026#39;; $key = hash(\u0026#39;sha256\u0026#39;, $key, true); $iv = \u0026#39;6732ebbdb62d93067ad6aad8\u0026#39;; $iv = hex2bin($iv); $encryptedText = \u0026#39;e8675abcd27f9b2b734504cb8adfbd88d8592c25960e8e7d4df060\u0026#39;; $tagLength = 32; $encryptedBindToken = hex2bin(substr($encryptedText, 0, -$tagLength)); $encrypted = openssl_encrypt($plainText, $cipher, $key, OPENSSL_RAW_DATA , $iv, $tag); echo \u0026#39;\u0026lt;pre\u0026gt;\u0026#39;;var_dump(bin2hex($encrypted));echo \u0026#39;\u0026lt;/pre\u0026gt;\u0026#39;;die(); } string(22) \u0026#34;e8675abcd27f9b2b734504\u0026#34; 發現咦這不是只有加密字串的前面嗎？\nOh, I just realized that this is not the entire encrypted string, but only the beginning part, right?\ne8675abcd27f9b2b734504cb8adfbd88d8592c25960e8e7d4df060\n所以真正的加密字串只有一段，後面是tag，解密的時候只要解密tag以外的那一段就好了\u0026hellip;\nSo the actual encrypted string consists of a portion followed by the tag. During decryption, we only need to decrypt the part excluding the tag\u0026hellip;\n立馬重新再解密一次\nLet me proceed with decrypting it again immediately.\npublic function testDecrypt() { $plainText = \u0026#39;hello world\u0026#39;; $cipher = \u0026#39;AES-256-GCM\u0026#39;; $key = \u0026#39;i_am_key\u0026#39;; $key = hash(\u0026#39;sha256\u0026#39;, $key, true); $iv = \u0026#39;6732ebbdb62d93067ad6aad8\u0026#39;; $iv = hex2bin($iv); $encryptedTextAndTag = \u0026#39;e8675abcd27f9b2b734504cb8adfbd88d8592c25960e8e7d4df060\u0026#39;; $tagLength = 32; $encryptedTextOnly = hex2bin(substr($encryptedTextAndTag, 0, -$tagLength)); $tag = hex2bin(substr($encryptedTextAndTag, -$tagLength)); $decrypted = openssl_decrypt($encryptedTextOnly, $cipher, $key, OPENSSL_RAW_DATA , $iv, $tag); $this-\u0026gt;assertEquals($decrypted, $plainText); } PHPUnit 9.6.9 by Sebastian Bergmann and contributors. ........ 8 / 8 (100%) Time: 00:00.048, Memory: 6.00 MB OK Bingo!\n參考資料 叉叉哥的BLOG ","description":"Conclusion The Process 參考資料 最近工作遇到一個專案，是要把透過Java使用AES-GCM加密過的資料解密，因為對方也沒有講清楚（或是不熟）導致解密有點不順利，不過後來還是成功解出來了，因此紀錄一下。\nIn a recent project, I had to decrypt data encrypted using AES-GCM in Java. Despite some initial challenges due to unclear instructions or lack of familiarity, I eventually succeeded in decrypting the data. Here\u0026rsquo;s a brief summary of the process.\nConclusion Java透過AES-GCM加密後的結果會包含兩部分：加密後字串+Tag，要解密時把字串拆開拿到Tag，並且只對加密後字串解密。\nwhen encrypting data using AES-GCM in Java, the resulting ciphertext will consist of two parts: the encrypted string and the tag. When decrypting, it is important to separate the ciphertext and retrieve the tag."},{"id":47,"href":"/tags/stacks.html","title":"stacks","parent":"Tags","content":"","description":""},{"id":48,"href":"/tags/hugo.html","title":"hugo","parent":"Tags","content":"","description":""},{"id":49,"href":"/tags/trash-talk.html","title":"trash talk","parent":"Tags","content":"","description":""},{"id":50,"href":"/tags/infra.html","title":"infra","parent":"Tags","content":"","description":""},{"id":51,"href":"/Programming/Languages/Java/Spring-Boot/Integrated-Spring/Integrate-Spirng-1.html","title":"Integrate Spring 1","parent":"Integrated Spring","content":"My same tree solution\n","description":"My same tree solution"},{"id":52,"href":"/Programming/Languages/Java/Spring-Boot/Integrated-Spring/same-tree.html","title":"Integrate Spring 2","parent":"Integrated Spring","content":"my solution\n","description":"my solution"},{"id":53,"href":"/Programming/Algorithm/Grind75/Tree/MaximumDepthOfBinaryTree.html","title":"Maximum Depth of Binary Tree","parent":"Tree","content":"My same tree solution\n","description":"My same tree solution"},{"id":54,"href":"/Programming/Algorithm/Grind75/Tree/SameTree.html","title":"Maximum Depth of Binary Tree","parent":"Tree","content":"my solution\n","description":"my solution"},{"id":55,"href":"/Programming/Languages/Java/Spring-Boot/Getting-started-with-Spring/two-sum.html","title":"Spring 2","parent":"Getting Started With Spring","content":"asdf My two sum solution\n","description":"asdf My two sum solution"},{"id":56,"href":"/Programming/Languages/Java/Spring-Boot/Getting-started-with-Spring/Start.html","title":"Start","parent":"Getting Started With Spring","content":"my solution\n","description":"my solution"},{"id":57,"href":"/","title":"","parent":"","content":" Jottings Programming Algorithm Language Site Story Why Hugo Hugo GitHub Page GitHub Action w/ VPS Install SSL Typora \u0026#43; Upic ","description":" Jottings Programming Algorithm Language Site Story Why Hugo Hugo GitHub Page GitHub Action w/ VPS Install SSL Typora \u0026#43; Upic "},{"id":58,"href":"/Programming/Languages/Java/Spring-Boot/Getting-started-with-Spring.html","title":"Getting Started With Spring","parent":"Spring Boot","content":"","description":""},{"id":59,"href":"/Programming/Languages/Java/Spring-Boot/Integrated-Spring.html","title":"Integrated Spring","parent":"Spring Boot","content":"","description":""},{"id":60,"href":"/Programming/Algorithm.html","title":"Algorithm","parent":"Programming","content":" Princeton Algorithms Grind 75 ","description":" Princeton Algorithms Grind 75 "},{"id":61,"href":"/Programming/Languages.html","title":"Language","parent":"Programming","content":"My leetcode blind 75 trip\u0026hellip;\nPHP JAVA Miscellaneous Chpher ","description":"My leetcode blind 75 trip\u0026hellip;\nPHP JAVA Miscellaneous Chpher "},{"id":62,"href":"/Programming/Algorithm/Algs4Princeton.html","title":"Princeton Algorithms","parent":"Algorithm","content":" Week 1 Union Find Dynamic Connectivity Quick Find Quick Union Weighted Quick Union Week 2 Stack And Queue Stacks Resizing Arrays Elementary Sorts ","description":" Week 1 Union Find Dynamic Connectivity Quick Find Quick Union Weighted Quick Union Week 2 Stack And Queue Stacks Resizing Arrays Elementary Sorts "},{"id":63,"href":"/Programming.html","title":"Programming","parent":"","content":" Algorithm Language Site Story Why Hugo Hugo GitHub Page GitHub Action w/ VPS Install SSL Typora \u0026#43; Upic ","description":" Algorithm Language Site Story Why Hugo Hugo GitHub Page GitHub Action w/ VPS Install SSL Typora \u0026#43; Upic "},{"id":64,"href":"/Programming/Algorithm/Algs4Princeton/Week2/StackAndQueue.html","title":"Stack And Queue","parent":"Week 2","content":" Stacks Resizing Arrays ","description":" Stacks Resizing Arrays "}]