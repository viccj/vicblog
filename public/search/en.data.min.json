[{"id":0,"href":"/Programming/Algorithm/Algs4Princeton/Week1/UnionFind/DynamicConnectivity.html","title":"Dynamic Connectivity","parent":"Union Find","content":" 前提 目的 相關應用 連接的定義 演算法實作 Union-find data type (API) 目標：為了union-find 設計一個有效率的資料結構 Union-find implementation[2] 參考來源 前提 Giving N objects\n目的 寫出演算法來完成以下兩點\nUnion command: connect two objects Find/connected query: Is there a path connecting the two objects? 假設給定的物件為 0,1,2,3,4,5,6,7,8,9，在執行完以下的union命令後，\nUnion(4, 3) Union(3, 8) Union(6, 5) Union(9, 4) Union(2, 1) connected(0, 7) // no connected connected(8, 9) // connected union(5, 0) union(7, 2) connected(0, 7) union(1, 0) // connected connectivity 的狀況會如下圖\n相關應用 數位照片的Pixels 在同一個網路的電腦 社群網站的好友 連接的定義 Reflexive: p 跟 p 自己連接 Symmetric: 若p跟q連接，q也跟p連接 Transitive: 若p跟q連接，q跟r連接，則p跟r連接 物件如果連接可以想成他們是在同一個component裏面，因此就剛剛的例子，會有2個component set\n{0,1,2,5,6,7} {3,4,8,9} 演算法實作 Find query: 檢查兩個物件是不是在相同的components Union command: 將兩個物件所在的component取聯集 Union-find data type (API) 目標：為了union-find 設計一個有效率的資料結構 其中\nNumber of object N can be huge. Number of operation M can be huge. Find queries and union commands may be intermixed(交錯進行). API 設計如下\npublic class UF --- UF(int N) // initialize N sites with integer names (0 to N-1) void union(int p, int q) // add connection between p and q int find(int p) // component identifier for p (0 to N-1) boolean connected(int p, int q) // return true if p and q are in the same component int count // number of components Union-find implementation[2] public class UF { private int[] id; // access to component id (site indexed) private int count; // number of components public UF(int n) { // Initialize component id array count = N; id = new int[N]; for (int i = 0; i \u0026lt; N; i++) { id[i] = i; } } public int count() { return count; } public boolean connected(int p, int q) { return find[p] == find[q]; } public int find(int p) { return id[p]; } public void union(int p, int q) { // Put p and q into the same component. int pID = find(p); int qID = find(q); // Nothing to do if p and q are already in the same component. if (pID == qID) return; // Rename p’s component to q’s name. for (int i = 0; i \u0026lt; id.length; i++) { if (id[i] == pID) id[i] = qID; count--; } } public static void main(String[] args) { // Read number of sites. int n = StdIn.readInt(); // Initialize N components. UF uf = new UF(n); while (!StdIn.isEmpty()) { int p = StdIn.readInt(); // Read pair to connect. int q = StdIn.readInt(); // Ignore if connected. if (uf.find(p) == uf.find(q)) continue; // Combine components uf.union(p, q); // Print connections. StdOut.println(p + \u0026#34; \u0026#34; + q); } StdOut.println(uf.count() + \u0026#34; components\u0026#34;); } } 參考來源 [1] Algorithms in Java, Lecture slide\n[2] Algorithms, 4th Edition\n","description":"前提 目的 相關應用 連接的定義 演算法實作 Union-find data type (API) 目標：為了union-find 設計一個有效率的資料結構 Union-find implementation[2] 參考來源 前提 Giving N objects\n目的 寫出演算法來完成以下兩點\nUnion command: connect two objects Find/connected query: Is there a path connecting the two objects? 假設給定的物件為 0,1,2,3,4,5,6,7,8,9，在執行完以下的union命令後，\nUnion(4, 3) Union(3, 8) Union(6, 5) Union(9, 4) Union(2, 1) connected(0, 7) // no connected connected(8, 9) // connected union(5, 0) union(7, 2) connected(0, 7) union(1, 0) // connected connectivity 的狀況會如下圖\n相關應用 數位照片的Pixels 在同一個網路的電腦 社群網站的好友 連接的定義 Reflexive: p 跟 p 自己連接 Symmetric: 若p跟q連接，q也跟p連接 Transitive: 若p跟q連接，q跟r連接，則p跟r連接 物件如果連接可以想成他們是在同一個component裏面，因此就剛剛的例子，會有2個component set"},{"id":1,"href":"/Programming/SiteStory/WhyHugo.html","title":"Why Hugo","parent":"Site Story","content":"\n為啥我搞了半天最後決定用 Hugo弄個網站？\n錯綜複雜的原因 斷斷續續的筆記習慣 VPS Domain 為了讓Domain的錢花得心安 Hugo 錯綜複雜的原因 會用Hugo架網站完全就是個意外，或許可以說是不同時間點覺得有趣的東西結合起來的結果。\n斷斷續續的筆記習慣 在轉職成為軟體工程師前，就有在記錄我最近學了什麼東西的習慣，原本是記在HackMD，但上班後就棄用了， 上班後用的東西就記在Apple Notes上，比較偏各專案得紀錄跟常用的指令。前陣子也有用過一陣子medium寫過幾篇刷題紀錄， 真的是幾篇就四篇吧 (而且都是複製別人的解法用自己的話重講一次，還都是easy)。\nVPS 跟Billy大神閒聊的時候知道他最近考過了AWS證照，夢想成為離前端越遠越好的軟體工程師的我很羨慕又欽佩，便在1 on 1的時候與主管聊起這話題，在主管的推薦下建議我可以先玩玩VPS，比起AWS單純也便宜，原理也都差不多，熟悉之後去用AWS會比較快上手因為AWS實在太雜了。\n然後我就馬上開了一開VPS起來然後發現我不知道要幹嘛\u0026hellip; 就又關掉了。\nDomain 做某專案的時候要請客戶提供Domain讓我們設定，或是我們幫他們弄一組，但我一開始完全不知道這些東西如何去用專業術語溝通，就問了旁邊的同事，發現他熟的跟啥一樣，我跟他比起來大概是全熟的牛排VS旁邊的生菜。\n後來知道他有在架NAS，也有買自己的Domain，還親手登入後台設定一遍給我看。聽到他有自己的domain我眼睛都亮起來了，感覺超屌，心想我一定也要一個自己的Domain。\n為了讓Domain的錢花得心安 接著好一陣子我每天朝思暮想要買一個domain，也去Godaddy上面瞎晃，不過畢竟 我也不是啥有錢人，買domain一定要物盡其用，只能為了說服我自己買domain而努力找出一個用途來，最好還要對我的職業生涯很有幫助。\n最後想著想著突然想到我可以用WordPress弄個blog來寫學習筆記，綁上我的domain！咦～聽起來不錯，便開始利用通勤時研究WordPress怎麼弄。\nHugo WordPress研究了半天，也不時看到其他架靜態blog的工具，發現這東西真是五花八門，馬上就又稍微研究了一下 (真的只有稍微)。\nJekyll：Ruby寫的，沒什麼感覺 Hugo：Go寫的，好像很潮 Hexo：Node.js寫的，直接刪掉 刪掉了Jekyll跟Hexo最後在wordpress跟Hugo選一個，一開始還是有點猶豫不決，最後壓垮我的倒數第二根稻草是看到一篇 Hugo+Github Action 自動部署到 VPS 的文章， 心裡想哇靠這不是把我的三個願望一次完成了嗎？還多點了一滴滴CI/CD。\n最後一根稻草是也去看了一下技術名人的網站，看到 良葛格的新網站 也是用Hugo架的，整個簡潔又專業。\n因此最後，就決定是Hugo了\n","description":"為啥我搞了半天最後決定用 Hugo弄個網站？\n錯綜複雜的原因 斷斷續續的筆記習慣 VPS Domain 為了讓Domain的錢花得心安 Hugo 錯綜複雜的原因 會用Hugo架網站完全就是個意外，或許可以說是不同時間點覺得有趣的東西結合起來的結果。\n斷斷續續的筆記習慣 在轉職成為軟體工程師前，就有在記錄我最近學了什麼東西的習慣，原本是記在HackMD，但上班後就棄用了， 上班後用的東西就記在Apple Notes上，比較偏各專案得紀錄跟常用的指令。前陣子也有用過一陣子medium寫過幾篇刷題紀錄， 真的是幾篇就四篇吧 (而且都是複製別人的解法用自己的話重講一次，還都是easy)。\nVPS 跟Billy大神閒聊的時候知道他最近考過了AWS證照，夢想成為離前端越遠越好的軟體工程師的我很羨慕又欽佩，便在1 on 1的時候與主管聊起這話題，在主管的推薦下建議我可以先玩玩VPS，比起AWS單純也便宜，原理也都差不多，熟悉之後去用AWS會比較快上手因為AWS實在太雜了。\n然後我就馬上開了一開VPS起來然後發現我不知道要幹嘛\u0026hellip; 就又關掉了。\nDomain 做某專案的時候要請客戶提供Domain讓我們設定，或是我們幫他們弄一組，但我一開始完全不知道這些東西如何去用專業術語溝通，就問了旁邊的同事，發現他熟的跟啥一樣，我跟他比起來大概是全熟的牛排VS旁邊的生菜。\n後來知道他有在架NAS，也有買自己的Domain，還親手登入後台設定一遍給我看。聽到他有自己的domain我眼睛都亮起來了，感覺超屌，心想我一定也要一個自己的Domain。\n為了讓Domain的錢花得心安 接著好一陣子我每天朝思暮想要買一個domain，也去Godaddy上面瞎晃，不過畢竟 我也不是啥有錢人，買domain一定要物盡其用，只能為了說服我自己買domain而努力找出一個用途來，最好還要對我的職業生涯很有幫助。\n最後想著想著突然想到我可以用WordPress弄個blog來寫學習筆記，綁上我的domain！咦～聽起來不錯，便開始利用通勤時研究WordPress怎麼弄。\nHugo WordPress研究了半天，也不時看到其他架靜態blog的工具，發現這東西真是五花八門，馬上就又稍微研究了一下 (真的只有稍微)。\nJekyll：Ruby寫的，沒什麼感覺 Hugo：Go寫的，好像很潮 Hexo：Node.js寫的，直接刪掉 刪掉了Jekyll跟Hexo最後在wordpress跟Hugo選一個，一開始還是有點猶豫不決，最後壓垮我的倒數第二根稻草是看到一篇 Hugo+Github Action 自動部署到 VPS 的文章， 心裡想哇靠這不是把我的三個願望一次完成了嗎？還多點了一滴滴CI/CD。\n最後一根稻草是也去看了一下技術名人的網站，看到 良葛格的新網站 也是用Hugo架的，整個簡潔又專業。\n因此最後，就決定是Hugo了"},{"id":2,"href":"/Programming/Algorithm/Blind75/Array/TwoSum.html","title":"Two Sum","parent":"Array","content":"My two sum solution\n","description":"My two sum solution"},{"id":3,"href":"/Programming/Languages/PHP.html","title":"PHP","parent":"Language","content":" PHP UNIT ","description":" PHP UNIT "},{"id":4,"href":"/Programming/Algorithm/Algs4Princeton/Week2/StackAndQueue/Stacks.html","title":"Stacks","parent":"Stack And Queue","content":"","description":""},{"id":5,"href":"/Programming/Algorithm/Algs4Princeton/Week1/UnionFind.html","title":"Union Find","parent":"Week 1","content":" Dynamic Connectivity Quick Find Quick Union Weighted Quick Union ","description":" Dynamic Connectivity Quick Find Quick Union Weighted Quick Union "},{"id":6,"href":"/Programming/Algorithm/Algs4Princeton/Week1.html","title":"Week 1","parent":"Princeton Algorithms","content":" Union Find Dynamic Connectivity Quick Find Quick Union Weighted Quick Union Analysis Of Algorithm ","description":" Union Find Dynamic Connectivity Quick Find Quick Union Weighted Quick Union Analysis Of Algorithm "},{"id":7,"href":"/Programming/Algorithm/Algs4Princeton/Week1/UnionFind/QuickFind.html","title":"Quick Find","parent":"Union Find","content":" Quick Find Structure 初始資料結構 Find Connected. Union. Implemetion Too slow Cost model Quick-find defect: Union too expensive 參考來源 Quick Find Structure 初始資料結構 名為 id[] 且數量為 N 的陣列\nid[p] 是物件 p 所屬於的 component id\n以上圖為例，id[6] = 0\nFind p 的 id 為？\nConnected. p 跟 q 是否有相同的 id？\nex: id[6] = 0, id[7] =1, 6 跟7 並沒有connect\nUnion. 要將包含 p 跟 q 的兩個components 合併，找出所有id 為 id[p] 的物件， 將其 id 修改成 id[q].\n如上圖，在union 6跟1之後，所有原本 id = id[6] 的id值變為 id[1]\nImplemetion public class QuickUF { private int[] id; public QuickFindUF(int N) { id = new int[N]; for (int i = 0; i \u0026lt; N; i++) { id[i] = i; } } public int find(int p) { return id[p]; } public boolean connected(int p, int q) { return id[p] == id[q]; } public void union(int p, int q) { int pId = id[p]; int qid = id[q]; for (int i = 0; i \u0026lt; id.length; i++) { if (id[i] == pid) { id[i] = qid; } } } } Too slow Cost model Algorithm initialize union Find Quick-find N N 1 Quick-find defect: Union too expensive Ex: 對於N個物件來說，如果有N個Union 指令，那會需要N2次\n因此要想辦法提高Union的效率\n參考來源 [1] Algorithms in Java, Lecture slide\n","description":"Quick Find Structure 初始資料結構 Find Connected. Union. Implemetion Too slow Cost model Quick-find defect: Union too expensive 參考來源 Quick Find Structure 初始資料結構 名為 id[] 且數量為 N 的陣列\nid[p] 是物件 p 所屬於的 component id\n以上圖為例，id[6] = 0\nFind p 的 id 為？\nConnected. p 跟 q 是否有相同的 id？\nex: id[6] = 0, id[7] =1, 6 跟7 並沒有connect\nUnion. 要將包含 p 跟 q 的兩個components 合併，找出所有id 為 id[p] 的物件， 將其 id 修改成 id[q]."},{"id":8,"href":"/Programming/Algorithm/Blind75/Array/BestTimeToBuyAndSellStock.html","title":"Best Time to Buy and Sell Stock","parent":"Array","content":"my solution\n","description":"my solution"},{"id":9,"href":"/Programming/SiteStory/GettingStart.html","title":"Hugo GitHub Page","parent":"Site Story","content":"離安裝好Hugo並胡搞瞎搞也過了大概一週，用我僅存的記憶記錄一下，前面都是湊字數的，重點是最後一段哈哈\n安裝Hugo 主題安裝 Github Page 抓不到css 安裝Hugo 因為我是Mac，所以直接用 brew intstall hugo安裝。\n安裝好之後就可以用 hugo new site blog-test來建立新的網站。\n主題安裝 安裝好Hugo之後，下一步就是挑選主題，我是使用 geekdoc 這個主題，主要是看到他的example site覺得很簡單，剛好我也不想花太多時間在把我的頁面弄的很fancy\n安裝的方法是直接下載他們的release bundle\n// 在themes的folder下面建立hugo-geekdoc的folder mkdir -p themes/hugo-geekdoc/ // 下載 curl -L https://github.com/thegeeklab/hugo-geekdoc/releases/latest/download/hugo-geekdoc.tar.gz | tar -xz -C themes/hugo-geekdoc/ --strip-components=1 安裝好之後再到Hugo的設定檔中把主題設定上去\ntheme = \u0026#34;hugo-geekdoc\u0026#34; 然後啟動Hugo就可以看到預設的頁面了\nhugo server -D 雖然hugo server會自動重build頁面，但是我發現有時候更改檔案內容或是資料夾結構，會無法正確顯示，這時候還是手動重啟hugo server比較穩。 編輯一下就可以用\nhugo 生成靜態內容，會建立一個public的資料夾將你剛剛的文件都放進去。\n然後就可以把他推到github的repository拉\nGithub Page 抓不到css 其實前面的步驟網路上都一堆教學，唯一我遇到的問題就是部署到github page後，發現\n我的css一直跑掉，打開開發工具看一下發現抓不到我的css跟js等檔案。\n在stackoverflow上找了半天，發現是相對路徑的問題，最後在config.toml檔案上加上\nrelativeURLs= true 就解決了。\n","description":"離安裝好Hugo並胡搞瞎搞也過了大概一週，用我僅存的記憶記錄一下，前面都是湊字數的，重點是最後一段哈哈\n安裝Hugo 主題安裝 Github Page 抓不到css 安裝Hugo 因為我是Mac，所以直接用 brew intstall hugo安裝。\n安裝好之後就可以用 hugo new site blog-test來建立新的網站。\n主題安裝 安裝好Hugo之後，下一步就是挑選主題，我是使用 geekdoc 這個主題，主要是看到他的example site覺得很簡單，剛好我也不想花太多時間在把我的頁面弄的很fancy\n安裝的方法是直接下載他們的release bundle\n// 在themes的folder下面建立hugo-geekdoc的folder mkdir -p themes/hugo-geekdoc/ // 下載 curl -L https://github.com/thegeeklab/hugo-geekdoc/releases/latest/download/hugo-geekdoc.tar.gz | tar -xz -C themes/hugo-geekdoc/ --strip-components=1 安裝好之後再到Hugo的設定檔中把主題設定上去\ntheme = \u0026#34;hugo-geekdoc\u0026#34; 然後啟動Hugo就可以看到預設的頁面了\nhugo server -D 雖然hugo server會自動重build頁面，但是我發現有時候更改檔案內容或是資料夾結構，會無法正確顯示，這時候還是手動重啟hugo server比較穩。 編輯一下就可以用\nhugo 生成靜態內容，會建立一個public的資料夾將你剛剛的文件都放進去。\n然後就可以把他推到github的repository拉\nGithub Page 抓不到css 其實前面的步驟網路上都一堆教學，唯一我遇到的問題就是部署到github page後，發現\n我的css一直跑掉，打開開發工具看一下發現抓不到我的css跟js等檔案。\n在stackoverflow上找了半天，發現是相對路徑的問題，最後在config.toml檔案上加上\nrelativeURLs= true 就解決了。"},{"id":10,"href":"/Programming/Algorithm/Algs4Princeton/Week1/AnalysisOfAlgorithm.html","title":"Analysis Of Algorithm","parent":"Week 1","content":" Mathematical Models ","description":" Mathematical Models "},{"id":11,"href":"/Programming/Languages/Java.html","title":"JAVA","parent":"Language","content":"My Java 75 trip\u0026hellip;\nSpring Boot ","description":"My Java 75 trip\u0026hellip;\nSpring Boot "},{"id":12,"href":"/Programming/Algorithm/Algs4Princeton/Week2/StackAndQueue/ResizingArrays.html","title":"Resizing Arrays","parent":"Stack And Queue","content":"","description":""},{"id":13,"href":"/Programming/Algorithm/Algs4Princeton/Week2.html","title":"Week 2","parent":"Princeton Algorithms","content":"","description":""},{"id":14,"href":"/Programming/Algorithm/Algs4Princeton/Week1/UnionFind/QuickUnion.html","title":"Quick Union","parent":"Union Find","content":" 初始資料結構 Root Find Union Implement Also too slow Cost model Quick-find defect Quick-union defect 參考來源 因為 Quick-find 演算法中，Union 的效率太低，因此要改善Union，在這章節稱為Quick Union （lazy approach），為什麼要叫Lazy approach呢？因為能躺著就不要做著，能坐著就不要站著，除非死到臨頭不然不要行動。\n初始資料結構 名為 id[] 且數量為 N 的陣列\nid[p] 是物件 p 所屬於的component id\n上面兩個與 Quick-find 一樣，但這次多了一個新的結構， root\nRoot 將一整個Array 看成 a set of trees，也就是說每個物件都屬於一個 tree，這個資料結構就是由很多 tree 集合而成。\n每個物件，會有一個Parent，如下圖，（3 可以接到4，3的 parent 是 4，4 的 parent 是 9) 順著線一直找，當找不到 parent 時，這時候就稱這點為 root\n如果這個物件只有自己，那自己就是root，例如1\nFind 因為每個物件都會有一個 root，要找兩個物件是不是同一個 component 的話，只要看他們的 root 是不是一樣就可以\nUnion 要將兩個物件（例如p, q) 合併，只要將 p 的 root 的 id 變成 q 的root的 id 就可以\n下圖為將9 跟6 合併的例子\n這時候只需要把id[9]改成6 就可以完成合併了\nImplement public class QuickUnionUF { private int[] id; // set id of each object to itself (N array access) public QuickFindUF(int N) { id = new int[N]; for (int i = 0; i \u0026lt; N; i++) { id[i] = i; } } // in the book, this is find in p224 public int root(int i) { while (i != id[i] ) { i = id[i]; } return i; } public boolean connected(int p, int q) { return root[p] == root[q]; } public void union(int p, int q) { int i = root[p]; int j = root[q]; id[i] = j } } Also too slow Cost model Algorithm initialize union Find Quick-find N N 1 Quick-union N N N Quick-find defect Union too expensive： 對於 N 個物件來說，如果有 N 個 Union 指令，那會需要執行 N2 次，因此要想辦法提高 Union 的效率 Quick-union defect Tree can be tall： 導致Find 效率太差 參考來源 [1] Algorithms in Java, Lecture slide\n","description":"初始資料結構 Root Find Union Implement Also too slow Cost model Quick-find defect Quick-union defect 參考來源 因為 Quick-find 演算法中，Union 的效率太低，因此要改善Union，在這章節稱為Quick Union （lazy approach），為什麼要叫Lazy approach呢？因為能躺著就不要做著，能坐著就不要站著，除非死到臨頭不然不要行動。\n初始資料結構 名為 id[] 且數量為 N 的陣列\nid[p] 是物件 p 所屬於的component id\n上面兩個與 Quick-find 一樣，但這次多了一個新的結構， root\nRoot 將一整個Array 看成 a set of trees，也就是說每個物件都屬於一個 tree，這個資料結構就是由很多 tree 集合而成。\n每個物件，會有一個Parent，如下圖，（3 可以接到4，3的 parent 是 4，4 的 parent 是 9) 順著線一直找，當找不到 parent 時，這時候就稱這點為 root\n如果這個物件只有自己，那自己就是root，例如1\nFind 因為每個物件都會有一個 root，要找兩個物件是不是同一個 component 的話，只要看他們的 root 是不是一樣就可以"},{"id":15,"href":"/Programming/SiteStory/GitHubActionWithVPS.html","title":"GitHub Action w/ VPS","parent":"Site Story","content":"","description":""},{"id":16,"href":"/Programming/SiteStory/SSL.html","title":"Install SSL","parent":"Site Story","content":"Domain 是在 namecheap 買的，設定好A紀錄跟CNAME之後就可以用了，再來就是申請SSL憑證 糊裡糊塗就把SSL弄好了，隨手記錄一下印象比較深刻的步驟跟坑。\n領取SSL憑證 收到憑證後 nginx設定 nginx -t 通過但是一直重啟不了nginx 領取SSL憑證 生成私鑰： openssl genrsa -out private.key 2048 生成一個2048位的RSA私鑰，並將其保存在名為 private.key 的文件中。\n接著用剛剛的私鑰生成CSR（證書簽署請求）\nopenssl req -new -key private.key -out csr.csr 會要求提供與SSL證書相關的信息，例如域名、組織名稱、所在地等。請根據提示輸入正確的信息。\nCommon Name (CN)：這邊要填你的域名 domain.com，它後面本來寫說填個名字就好我就傻傻的填我的英文名字，結果一直失敗..\n生成的CSR文件 csr.csr 就可以整個複製上去。 收到憑證後 通常在取得 SSL 憑證時，您會收到兩個檔案：.crt 憑證檔案和 .ca-bundle（或 .bundle）憑證束檔案。\n.crt 憑證檔案是您的 SSL 證書，它包含您的網站的公開金鑰以及其他相關的證書資訊。\n.ca-bundle（或 .bundle）憑證束檔案是根憑證和中繼憑證的集合。它包含了憑證鏈中的所有憑證，用於驗證您的 SSL 憑證的合法性。憑證鏈包括根憑證（Root Certificate）和中繼憑證（Intermediate Certificate）。根憑證是由受信任的憑證授權中心（Certificate Authority）簽署的，而中繼憑證是由根憑證簽署的其他憑證。\n在設定 Nginx 的 SSL 時，需要將 .crt 憑證檔案和 .ca-bundle（或 .bundle）憑證束檔案合併為一個檔案，形成完整的憑證鏈。\n順序不能錯，要先crt再ca-bundle\ncat domain.crt domain.ca-bundle \u0026gt; server.crt nginx設定 # HTTP 重定向到 HTTPS server { listen 80; server_name lazyvic.com; return 301 https://lazyvic.com$request_uri; # 返回 301 重定向到相應的 HTTPS URL } # HTTPS 配置 server { listen 443 ssl; # 監聽 443 端口，啟用 SSL server_name lazyvic.com; ssl_certificate /etc/nginx/ssl/server.crt; # SSL 憑證路徑 ssl_certificate_key /etc/nginx/ssl/private.key; # SSL 憑證私鑰路徑 location / { root /var/www/html/public; # 根目錄，用於存放網站文件 index index.html index.htm; # 默認索引文件 } # 自定義 404 頁面 error_page 404 /404.html; location = /404.html { # 這裡可以指定自定義的 404 頁面的路徑和檔名 } # 自定義 50x 錯誤頁面 error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; # 50x 錯誤頁面的路徑 } } nginx -t 通過但是一直重啟不了nginx 在重啟前有先用 nginx -t 確認無誤，但是重啟nginx卻一直失敗，看了log說是沒有權限取得檔案，查了一下解法如下：\nrestorecon -v -R /etc/nginx 查了一下這個restorecon到底是啥東西\nrestorecon 指令用於恢復檔案和目錄的 SELinux 安全上下文。在某些 Linux 發行版中，如 CentOS 和 RHEL，安全上下文是用於控制檔案和目錄的存取權限和 SELinux 政策的一部分。\n當您遭遇 Nginx SSL 憑證無法載入的問題時，有時是由於 SELinux 安全上下文不正確導致的。透過執行 restorecon 指令，您可以將 /etc/nginx 目錄及其內部的檔案和目錄恢復為預設的 SELinux 安全上下文。\n這樣做可以確保 Nginx 服務以適當的安全上下文執行，並且具有正確的存取權限，從而能夠正確載入並使用 SSL 憑證。\n","description":"Domain 是在 namecheap 買的，設定好A紀錄跟CNAME之後就可以用了，再來就是申請SSL憑證 糊裡糊塗就把SSL弄好了，隨手記錄一下印象比較深刻的步驟跟坑。\n領取SSL憑證 收到憑證後 nginx設定 nginx -t 通過但是一直重啟不了nginx 領取SSL憑證 生成私鑰： openssl genrsa -out private.key 2048 生成一個2048位的RSA私鑰，並將其保存在名為 private.key 的文件中。\n接著用剛剛的私鑰生成CSR（證書簽署請求）\nopenssl req -new -key private.key -out csr.csr 會要求提供與SSL證書相關的信息，例如域名、組織名稱、所在地等。請根據提示輸入正確的信息。\nCommon Name (CN)：這邊要填你的域名 domain.com，它後面本來寫說填個名字就好我就傻傻的填我的英文名字，結果一直失敗..\n生成的CSR文件 csr.csr 就可以整個複製上去。 收到憑證後 通常在取得 SSL 憑證時，您會收到兩個檔案：.crt 憑證檔案和 .ca-bundle（或 .bundle）憑證束檔案。\n.crt 憑證檔案是您的 SSL 證書，它包含您的網站的公開金鑰以及其他相關的證書資訊。\n.ca-bundle（或 .bundle）憑證束檔案是根憑證和中繼憑證的集合。它包含了憑證鏈中的所有憑證，用於驗證您的 SSL 憑證的合法性。憑證鏈包括根憑證（Root Certificate）和中繼憑證（Intermediate Certificate）。根憑證是由受信任的憑證授權中心（Certificate Authority）簽署的，而中繼憑證是由根憑證簽署的其他憑證。\n在設定 Nginx 的 SSL 時，需要將 .crt 憑證檔案和 .ca-bundle（或 .bundle）憑證束檔案合併為一個檔案，形成完整的憑證鏈。\n順序不能錯，要先crt再ca-bundle\ncat domain.crt domain.ca-bundle \u0026gt; server.crt nginx設定 # HTTP 重定向到 HTTPS server { listen 80; server_name lazyvic."},{"id":17,"href":"/Programming/Algorithm/Algs4Princeton/Week1/UnionFind/WeithgedQuickUnion.html","title":"Weighted Quick Union","parent":"Union Find","content":" Imporvement 1: weighting Data Structure Find Union Implement Weighted quick-union analysis Running time. Proposition Can we impove it even further? 參考來源 How to imporvements Quick-union?\n上一篇中， Quick-Union 演算法中，最後可能因為每個tree長得太高，導致效率變差。\nImporvement 1: weighting 在每次 Union 時，順帶記錄每棵樹的 size (number of objects)\n在每次 Union 時，刻意將較小的樹連接到較大的樹下\nData Structure 與 quick-union 一樣，但多追蹤每棵樹的大小 (size of objects for roots)\nFind 與 quick-union 一樣\nUnion 修改為：\n將小的樹往大的樹接 更新 sz[] array Implement public class QuickUnionUF { private int[] id; private int[] sz; // size of objects for roots (site indexed) // set id of each object to itself (N array access) public WeightedQuickFindUF(int N) { id = new int[N]; for (int i = 0; i \u0026lt; N; i++) { id[i] = i; } // init sz of every objects sz = new int[N]; for (int i = 0; i \u0026lt; N; i++) { sz[i] = 1; } } public int root(int i) { while (i != id[i] ) { i = id[i]; } return i; } public boolean connected(int p, int q) { return root[p] == root[q]; } public void union(int p, int q) { int i = root[p]; int j = root[q]; if (i == j) { return; } if (sz[i] \u0026lt; sz[j]) { id[i] = j; sz[j] += sz[i]; } else { id[j] = i; sz[i] += sz[j]; } id[i] = j } } Weighted quick-union analysis Running time. Find: takes time proportional to depth of p and q. Union: takes constant time, given roots. Proposition Depth of any node x is at most lg N (log- base-2 logarithm).\n這裡一開始比較難以理解，教授的原話如下\nSo, when the depth of x increases, the size of its tree at least doubles. So, that\u0026rsquo;s the key because that means that the size of the tree containing x can double at most log N times because if you start with one and double log N times, you get N and there\u0026rsquo;s only N nodes in the tree.\n看了書之後我的理解是：\nMaximum height of a tree only increases when 2 trees with same height are merged.\nYou can make maximum logN merges of such trees. (as you will have to keep dividing N with 2 to form i amount of such trees. At the example with N=8 below, you create equally sized trees to merge max 3 times.\nTherefore, depth of any node x is at most LogN. (due to max height)\n假設N是8，每次union後會多一層，每個樹的 objects 數量最多變兩倍，這樣一來對任何一顆樹而言 union 到最後最多只有三層. (log8)，因此對有 N個 object 的集合來說，每一顆 node的深度最多就是 logN。可以大幅減少每個 node 的 depth。\nAlgorithm initialize union Find Quick-find N N 1 Quick-union N N N Withgted QU N lg N Lg N Can we impove it even further? 其實是可以的，而且只要多一行code。\n概念是：每次在尋找root的時候，將找到的 children node 都連向 root，這樣可以使得最後的樹趨近於平整\npublic int root(int i) { while (i != id[i] ) { id[i] = id[id[i]] // one more line of code i = id[i]; } return i; } 參考來源 [1] Algorithms in Java, Lecture slide\n","description":"Imporvement 1: weighting Data Structure Find Union Implement Weighted quick-union analysis Running time. Proposition Can we impove it even further? 參考來源 How to imporvements Quick-union?\n上一篇中， Quick-Union 演算法中，最後可能因為每個tree長得太高，導致效率變差。\nImporvement 1: weighting 在每次 Union 時，順帶記錄每棵樹的 size (number of objects)\n在每次 Union 時，刻意將較小的樹連接到較大的樹下\nData Structure 與 quick-union 一樣，但多追蹤每棵樹的大小 (size of objects for roots)\nFind 與 quick-union 一樣\nUnion 修改為：\n將小的樹往大的樹接 更新 sz[] array Implement public class QuickUnionUF { private int[] id; private int[] sz; // size of objects for roots (site indexed) // set id of each object to itself (N array access) public WeightedQuickFindUF(int N) { id = new int[N]; for (int i = 0; i \u0026lt; N; i++) { id[i] = i; } // init sz of every objects sz = new int[N]; for (int i = 0; i \u0026lt; N; i++) { sz[i] = 1; } } public int root(int i) { while (i !"},{"id":18,"href":"/Programming/SiteStory/TyporaUpic.html","title":"Typora + Upic","parent":"Site Story","content":"Hugo是用MarkDown來編輯文件的，這時候有個好用的MarkDown 編輯器就很好用，最後我是選擇用Typroa來編輯文件，再貼到Hugo發布，會選擇Typora的原因是因為Typora支援自動上傳圖片並產生連結功能，非常適合Lazy的我。 簡單記錄一下如何用uPic自動上傳圖片到我的GitHub\nGitHub開一個新的Repo並產生token uPic 安裝uPic 配置 Typora設定 GitHub開一個新的Repo並產生token 在GitHub首頁-\u0026gt;setting-\u0026gt;Developer Setting-\u0026gt; Personal Ascess Token裡面產生一組新的Token。\n我是選classic的token，因為看到另一個還在beta。\n可以只勾public_repo，剩下我都沒勾，Note隨便打就好。\nuPic 安裝uPic brew install bigwig-club/brew/upic --cask 配置 安裝好之後打開uPic，是Mac的話會在最上面那一條出現，一開始沒注意到還一直想說怎麼打不開\u0026hellip;\n進入設定頁面\nOwner -\u0026gt; 你的github帳號 Repo -\u0026gt; 你的repo Token-\u0026gt; GitHub token 然後可以按下驗證聽說會有成功畫面出現，但我按了都沒反應就是了。最後是去Typora那邊測試可不可以成功\n設定好後再把uPic預設上傳方式改成GitHub即可\nTypora設定 照著設定按一下test Uploader顯示成功，之後圖片拖進來就會自動寫好Markdown嚕。\n","description":"Hugo是用MarkDown來編輯文件的，這時候有個好用的MarkDown 編輯器就很好用，最後我是選擇用Typroa來編輯文件，再貼到Hugo發布，會選擇Typora的原因是因為Typora支援自動上傳圖片並產生連結功能，非常適合Lazy的我。 簡單記錄一下如何用uPic自動上傳圖片到我的GitHub\nGitHub開一個新的Repo並產生token uPic 安裝uPic 配置 Typora設定 GitHub開一個新的Repo並產生token 在GitHub首頁-\u0026gt;setting-\u0026gt;Developer Setting-\u0026gt; Personal Ascess Token裡面產生一組新的Token。\n我是選classic的token，因為看到另一個還在beta。\n可以只勾public_repo，剩下我都沒勾，Note隨便打就好。\nuPic 安裝uPic brew install bigwig-club/brew/upic --cask 配置 安裝好之後打開uPic，是Mac的話會在最上面那一條出現，一開始沒注意到還一直想說怎麼打不開\u0026hellip;\n進入設定頁面\nOwner -\u0026gt; 你的github帳號 Repo -\u0026gt; 你的repo Token-\u0026gt; GitHub token 然後可以按下驗證聽說會有成功畫面出現，但我按了都沒反應就是了。最後是去Typora那邊測試可不可以成功\n設定好後再把uPic預設上傳方式改成GitHub即可\nTypora設定 照著設定按一下test Uploader顯示成功，之後圖片拖進來就會自動寫好Markdown嚕。"},{"id":19,"href":"/Programming/Algorithm/Blind75.html","title":"Blind 75","parent":"Algorithm","content":" List of Blind 75 Array Two Sum Best Time to Buy and Sell Stock Level 1.3 Level 1.3.1 Tree Maximum Depth of Binary Tree Maximum Depth of Binary Tree ","description":" List of Blind 75 Array Two Sum Best Time to Buy and Sell Stock Level 1.3 Level 1.3.1 Tree Maximum Depth of Binary Tree Maximum Depth of Binary Tree "},{"id":20,"href":"/Programming/Languages/Miscellaneous/cipher.html","title":"Chpher","parent":"Miscellaneous","content":" Decrypt AES-GCM encoded content with JAVA Cipher using PHP OpenSSL ","description":" Decrypt AES-GCM encoded content with JAVA Cipher using PHP OpenSSL "},{"id":21,"href":"/Programming/Algorithm/Grind75.html","title":"Grind 75","parent":"Algorithm","content":" Grind 75 Week1 Best Time to Buy and Sell Stock two sum Level 1.3 Level 1.3.1 Week2 Maximum Depth of Binary Tree Maximum Depth of Binary Tree ","description":" Grind 75 Week1 Best Time to Buy and Sell Stock two sum Level 1.3 Level 1.3.1 Week2 Maximum Depth of Binary Tree Maximum Depth of Binary Tree "},{"id":22,"href":"/Programming/Algorithm/Blind75/Array/test.html","title":"Level 1.3","parent":"Array","content":"Nested folder test\nLevel 1.3.1 ","description":"Nested folder test\nLevel 1.3.1 "},{"id":23,"href":"/Programming/Algorithm/Grind75/Week1/test.html","title":"Level 1.3","parent":"Week1","content":"Nested folder test\nLevel 1.3.1 ","description":"Nested folder test\nLevel 1.3.1 "},{"id":24,"href":"/Programming/Languages/Java/Spring-Boot/Getting-started-with-Spring/test.html","title":"Level 1.3","parent":"Getting Started With Spring","content":"Nested folder test\nLevel 1.3.1 ","description":"Nested folder test\nLevel 1.3.1 "},{"id":25,"href":"/Programming/Algorithm/Blind75/Array/test/two-sum.html","title":"Level 1.3.1","parent":"Level 1.3","content":"Level 1.3.1\n","description":"Level 1.3.1"},{"id":26,"href":"/Programming/Algorithm/Grind75/Week1/test/two-sum.html","title":"Level 1.3.1","parent":"Level 1.3","content":"Level 1.3.1\n","description":"Level 1.3.1"},{"id":27,"href":"/Programming/Languages/Java/Spring-Boot/Getting-started-with-Spring/test/two-sum.html","title":"Level 1.3.1","parent":"Level 1.3","content":"Level 1.3.1\n","description":"Level 1.3.1"},{"id":28,"href":"/Programming/Languages/Miscellaneous.html","title":"Miscellaneous","parent":"Language","content":"Jotting the various pitfalls and challenges i encountered\nChpher ","description":"Jotting the various pitfalls and challenges i encountered\nChpher "},{"id":29,"href":"/Programming/Languages/PHP/PhpUnit.html","title":"PHP UNIT","parent":"PHP","content":"My leetcode blind 75 trip\u0026hellip;\nBasic Setting ","description":"My leetcode blind 75 trip\u0026hellip;\nBasic Setting "},{"id":30,"href":"/Programming/SiteStory.html","title":"Site Story","parent":"Programming","content":" Why Hugo Hugo GitHub Page GitHub Action w/ VPS Install SSL Typora \u0026#43; Upic ","description":" Why Hugo Hugo GitHub Page GitHub Action w/ VPS Install SSL Typora \u0026#43; Upic "},{"id":31,"href":"/Programming/Languages/Java/Spring-Boot.html","title":"Spring Boot","parent":"JAVA","content":"My leetcode blind 75 trip\u0026hellip;\nGetting Started With Spring Spring 2 Start Level 1.3 Level 1.3.1 Integrated Spring Integrate Spring 1 Integrate Spring 2 ","description":"My leetcode blind 75 trip\u0026hellip;\nGetting Started With Spring Spring 2 Start Level 1.3 Level 1.3.1 Integrated Spring Integrate Spring 1 Integrate Spring 2 "},{"id":32,"href":"/Programming/Languages/PHP/PhpUnit/BasicSetting.html","title":"Basic Setting","parent":"PHP UNIT","content":" PHPUnit 安裝 建立設定檔 phpunit.xml 一次執行所有test phpunit.xml 常用參數 The bootstrap Attribute The cacheDirectory Attribute The cacheResult Attribute The colors Attribute PHPUnit 安裝 composer require --dev phpunit/phpunit 安裝完之後就可以執行測試\nphp vendor/bin/phpunit yourTest.php 建立設定檔 phpunit.xml 一次執行所有test 建立一個 phpunit.xml檔案，並在裡面指定路徑，之後這個folder裡面所有的測試就會被執行\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;phpunit bootstrap=\u0026#34;bootstrap.php\u0026#34; colors=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;testsuites\u0026gt; \u0026lt;testsuite name=\u0026#34;All Tests\u0026#34;\u0026gt; \u0026lt;directory\u0026gt;tests\u0026lt;/directory\u0026gt; \u0026lt;/testsuite\u0026gt; \u0026lt;/testsuites\u0026gt; \u0026lt;/phpunit\u0026gt; 之後這個 folder 裡面所有的測試就會被執行 (測試的檔名要是Test 結尾，測試的method 要是 test 開頭)\nappTest.php\n\u0026lt;?php class appTest extends TestCase { public function testSomething() { assertTrue(true); } } php vendor/bin/phpunit phpunit.xml 常用參數 The bootstrap Attribute This attribute configures the bootstrap script that is loaded before the tests are executed. This script usually only registers the autoloader callback that is used to load the code under test.\nThe cacheDirectory Attribute This attribute configures the directory in which PHPUnit caches information such as test results (see below) or the result of static code analysis that is performed for code coverage reporting.\nThe cacheResult Attribute Possible values: true or false (default: true)\nThis attribute configures the caching of test results. This caching is required for ordering tests by defects or duration with the executionOrder attribute (see The executionOrder Attribute).\nThe colors Attribute Possible values: true or false (default: false)\nThis attribute configures whether colors are used in PHPUnit’s output.\nSetting this attribute to true is equivalent to using the --colors=auto CLI option.\nSetting this attribute to false is equivalent to using the --colors=never CLI option.\n","description":"PHPUnit 安裝 建立設定檔 phpunit.xml 一次執行所有test phpunit.xml 常用參數 The bootstrap Attribute The cacheDirectory Attribute The cacheResult Attribute The colors Attribute PHPUnit 安裝 composer require --dev phpunit/phpunit 安裝完之後就可以執行測試\nphp vendor/bin/phpunit yourTest.php 建立設定檔 phpunit.xml 一次執行所有test 建立一個 phpunit.xml檔案，並在裡面指定路徑，之後這個folder裡面所有的測試就會被執行\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;phpunit bootstrap=\u0026#34;bootstrap.php\u0026#34; colors=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;testsuites\u0026gt; \u0026lt;testsuite name=\u0026#34;All Tests\u0026#34;\u0026gt; \u0026lt;directory\u0026gt;tests\u0026lt;/directory\u0026gt; \u0026lt;/testsuite\u0026gt; \u0026lt;/testsuites\u0026gt; \u0026lt;/phpunit\u0026gt; 之後這個 folder 裡面所有的測試就會被執行 (測試的檔名要是Test 結尾，測試的method 要是 test 開頭)\nappTest.php\n\u0026lt;?php class appTest extends TestCase { public function testSomething() { assertTrue(true); } } php vendor/bin/phpunit phpunit."},{"id":33,"href":"/tags/php.html","title":"php","parent":"Tags","content":"","description":""},{"id":34,"href":"/tags.html","title":"Tags","parent":"","content":"","description":""},{"id":35,"href":"/tags/unittest.html","title":"unittest","parent":"Tags","content":"","description":""},{"id":36,"href":"/tags/Algorithm.html","title":"Algorithm","parent":"Tags","content":"","description":""},{"id":37,"href":"/tags/cipher.html","title":"cipher","parent":"Tags","content":"","description":""},{"id":38,"href":"/Programming/Languages/Miscellaneous/cipher/Decrypt-AES-GCM-encoded-content-with-JAVA-Cipher-using-PHP-OpenSSL.html","title":"Decrypt AES-GCM encoded content with JAVA Cipher using PHP OpenSSL","parent":"Chpher","content":" Conclusion The Process 參考資料 最近工作遇到一個專案，是要把透過Java使用AES-GCM加密過的資料解密，因為對方也沒有講清楚（或是不熟）導致解密有點不順利，不過後來還是成功解出來了，因此紀錄一下。\nIn a recent project, I had to decrypt data encrypted using AES-GCM in Java. Despite some initial challenges due to unclear instructions or lack of familiarity, I eventually succeeded in decrypting the data. Here\u0026rsquo;s a brief summary of the process.\nConclusion Java透過AES-GCM加密後的結果會包含兩部分：加密後字串+Tag，要解密時把字串拆開拿到Tag，並且只對加密後字串解密。\nwhen encrypting data using AES-GCM in Java, the resulting ciphertext will consist of two parts: the encrypted string and the tag. When decrypting, it is important to separate the ciphertext and retrieve the tag. The decryption process should only be applied to the encrypted string part.\nThe Process Given data:\nCipher: AES-GCM Key: i_am_key (to be hashed using SHA-256) IV: 6732ebbdb62d93067ad6aad8 (hex) encryptedText: e8675abcd27f9b2b734504cb8adfbd88d8592c25960e8e7d4df060 plainText: \u0026lsquo;hello world\u0026rsquo; 一開始只有這些資訊，因此我直接先試試看，因為有特地提到 key 要 sha256 hash，因此我判斷是用AES-256-GCM算法\nWith the initial information provided, I proceeded with the decryption attempt. Since it was specifically mentioned that the key needed to be hashed using SHA-256, I determined that the AES-256-GCM algorithm was being used.\npublic function testDecrypt() { $plainText = \u0026#39;hello world\u0026#39;; $cipher = \u0026#39;AES-256-GCM\u0026#39;; $key = \u0026#39;i_am_key\u0026#39;; $key = hash(\u0026#39;sha256\u0026#39;, $key, true); $iv = \u0026#39;6732ebbdb62d93067ad6aad8\u0026#39;; $iv = hex2bin($iv); $encryptedText = \u0026#39;e8675abcd27f9b2b734504cb8adfbd88d8592c25960e8e7d4df060\u0026#39;; $encryptedBindToken = hex2bin(substr($encryptedText, 0, -$tagLength)); $tag = hex2bin(substr($encryptedText, -$tagLength)); $decrypted = openssl_decrypt(bin2hex($encryptedText), $cipher, $key, OPENSSL_RAW_DATA , $iv); $this-\u0026gt;assertEquals($decrypted, $plainText); } Get false directly, unexpectedly.\nPHPUnit 9.6.9 by Sebastian Bergmann and contributors. Time: 00:00.060, Memory: 6.00 MB There was 1 failure: 1) xxxTest::testDecrypt Failed asserting that \u0026#39;hello world\u0026#39; matches expected false. FAILURES! 因此便去查一下資料，發現透過AES-GCM加密後會有一個 Tag 值，這個值也是解密會用到的\nTherefore, I proceeded to look up the information and found that when using AES-GCM encryption, there is a tag value generated, which is also used during the decryption process.\nThe GCM document from NIST (National Institute of Standards and Technology)\nThe following two bit strings comprise the output data of the authenticated encryption function:\n• A ciphertext, denoted C, whose bit length is the same as that of the plaintext.\n• An authentication tag, or tag, for short, denoted T.\n下面這個RFC也有提到會有一個 \u0026ldquo;Tag\u0026rdquo;\nThe RFC, also mentions the presence of a \u0026ldquo;Tag\u0026rdquo;\nAES-GCM has four inputs: an AES key, an initialization vector (IV), a plaintext content, and optional additional authenticated data (AAD).\nAES-GCM generates two outputs: a ciphertext and message authentication code (also called an authentication tag).\n但是我並沒有這個 \u0026ldquo;Tag\u0026rdquo;，客戶也沒提供，因此後來又去查一下資料，看看有沒有辦法透過已經有的資料推出Tag，後來被我查到了，Tag就在加密後字串的最後面(至少用Java加密後的是這樣)\nHowever, I did not have this \u0026ldquo;Tag\u0026rdquo; and the client did not provide it either. So I further researched and tried to find a way to derive the Tag using the available data. Eventually, I found it! The Tag is located at the end of the encrypted string (at least for Java).\nIn Java the tag is unfortunately added at the end of the ciphertext. - StackOverFlow\n所以客戶提供的字串會有一段是tag，但目前還是不知道長度是多少，本來想直接問一下他們tag長度設定多少，但還是算了，先試試看預設長度 128bits。\nSo the string provided contains a section that represents the tag. However, the length of the tag is still unknown. Initially, I thought about directly asking for the tag length, but I decided to try it using the default length of 128 bits.\n因為提供的hex的加密字串，所以直接取的話要算32個字元，如果轉成binary，只要取16個字元就好，這邊就直接抓最後32字元\nSince the provided encrypted string is in hexadecimal format, if we consider each hex digit as one character, it would require 32 characters. However, if we convert it to binary format, we only need 16 characters. Therefore, I will directly extract the last 32 characters as the tag.\npublic function testDecrypt() { $plainText = \u0026#39;hello world\u0026#39;; $cipher = \u0026#39;AES-256-GCM\u0026#39;; $key = \u0026#39;i_am_key\u0026#39;; $key = hash(\u0026#39;sha256\u0026#39;, $key, true); $iv = \u0026#39;6732ebbdb62d93067ad6aad8\u0026#39;; $iv = hex2bin($iv); $encryptedText = \u0026#39;e8675abcd27f9b2b734504cb8adfbd88d8592c25960e8e7d4df060\u0026#39;; $tagLength = 32; $tag = hex2bin(substr($encryptedText, -$tagLength)); $decrypted = openssl_decrypt(bin2hex($encryptedText), $cipher, $key, OPENSSL_RAW_DATA , $iv, $tag); $this-\u0026gt;assertEquals($decrypted, $plainText); } PHPUnit 9.6.9 by Sebastian Bergmann and contributors. Time: 00:00.060, Memory: 6.00 MB There was 1 failure: 1) xxxTest::testDecrypt Failed asserting that \u0026#39;hello world\u0026#39; matches expected false. FAILURES! 結果還是 false，不知道是哪邊弄錯了，難道是tag長度弄錯了?!\nThe result still turned out to be \u0026ldquo;false,\u0026rdquo; and I\u0026rsquo;m not sure where the mistake lies. Could it be that the tag length was set incorrectly?!\n但後來想到既然沒提供 Tag 的話，代表他們八成也是用預設長度（後來證明沒錯，測了幾個長度的 tag 也是失敗）\nHowever, later on, I realized that if they didn\u0026rsquo;t provide the tag, it probably means they also used the default length (which was later confirmed to be true as testing different tag lengths also failed).\n最後真的沒辦法了，自己用 key 跟 iv 加密一次看一下結果如何\nIn the end, when all else failed, I decided to encrypt it myself using the key and IV and see what the result would be.\npublic function testEncrypt() { $plainText = \u0026#39;hello world\u0026#39;; $cipher = \u0026#39;AES-256-GCM\u0026#39;; $key = \u0026#39;i_am_key\u0026#39;; $key = hash(\u0026#39;sha256\u0026#39;, $key, true); $iv = \u0026#39;6732ebbdb62d93067ad6aad8\u0026#39;; $iv = hex2bin($iv); $encryptedText = \u0026#39;e8675abcd27f9b2b734504cb8adfbd88d8592c25960e8e7d4df060\u0026#39;; $tagLength = 32; $encryptedBindToken = hex2bin(substr($encryptedText, 0, -$tagLength)); $encrypted = openssl_encrypt($plainText, $cipher, $key, OPENSSL_RAW_DATA , $iv, $tag); echo \u0026#39;\u0026lt;pre\u0026gt;\u0026#39;;var_dump(bin2hex($encrypted));echo \u0026#39;\u0026lt;/pre\u0026gt;\u0026#39;;die(); } string(22) \u0026#34;e8675abcd27f9b2b734504\u0026#34; 發現咦這不是只有加密字串的前面嗎？\nOh, I just realized that this is not the entire encrypted string, but only the beginning part, right?\ne8675abcd27f9b2b734504cb8adfbd88d8592c25960e8e7d4df060\n所以真正的加密字串只有一段，後面是tag，解密的時候只要解密tag以外的那一段就好了\u0026hellip;\nSo the actual encrypted string consists of a portion followed by the tag. During decryption, we only need to decrypt the part excluding the tag\u0026hellip;\n立馬重新再解密一次\nLet me proceed with decrypting it again immediately.\npublic function testDecrypt() { $plainText = \u0026#39;hello world\u0026#39;; $cipher = \u0026#39;AES-256-GCM\u0026#39;; $key = \u0026#39;i_am_key\u0026#39;; $key = hash(\u0026#39;sha256\u0026#39;, $key, true); $iv = \u0026#39;6732ebbdb62d93067ad6aad8\u0026#39;; $iv = hex2bin($iv); $encryptedTextAndTag = \u0026#39;e8675abcd27f9b2b734504cb8adfbd88d8592c25960e8e7d4df060\u0026#39;; $tagLength = 32; $encryptedTextOnly = hex2bin(substr($encryptedTextAndTag, 0, -$tagLength)); $tag = hex2bin(substr($encryptedTextAndTag, -$tagLength)); $decrypted = openssl_decrypt($encryptedTextOnly, $cipher, $key, OPENSSL_RAW_DATA , $iv, $tag); $this-\u0026gt;assertEquals($decrypted, $plainText); } PHPUnit 9.6.9 by Sebastian Bergmann and contributors. ........ 8 / 8 (100%) Time: 00:00.048, Memory: 6.00 MB OK Bingo!\n參考資料 叉叉哥的BLOG ","description":"Conclusion The Process 參考資料 最近工作遇到一個專案，是要把透過Java使用AES-GCM加密過的資料解密，因為對方也沒有講清楚（或是不熟）導致解密有點不順利，不過後來還是成功解出來了，因此紀錄一下。\nIn a recent project, I had to decrypt data encrypted using AES-GCM in Java. Despite some initial challenges due to unclear instructions or lack of familiarity, I eventually succeeded in decrypting the data. Here\u0026rsquo;s a brief summary of the process.\nConclusion Java透過AES-GCM加密後的結果會包含兩部分：加密後字串+Tag，要解密時把字串拆開拿到Tag，並且只對加密後字串解密。\nwhen encrypting data using AES-GCM in Java, the resulting ciphertext will consist of two parts: the encrypted string and the tag. When decrypting, it is important to separate the ciphertext and retrieve the tag."},{"id":39,"href":"/tags/java.html","title":"java","parent":"Tags","content":"","description":""},{"id":40,"href":"/Programming/Algorithm/Algs4Princeton/Week1/AnalysisOfAlgorithm/MathematicalModels/MathematicalModels.html","title":"Mathematical Models","parent":"Mathematical Models","content":"my solution\n","description":"my solution"},{"id":41,"href":"/Programming/Algorithm/Algs4Princeton/Week2/StackAndQueue/ResizingArrays/ResizingArrays.html","title":"Resizing Arrays","parent":"Resizing Arrays","content":"my solution\n","description":"my solution"},{"id":42,"href":"/Programming/Algorithm/Algs4Princeton/Week2/StackAndQueue/Stacks/UnionFind.html","title":"Stacks","parent":"Stacks","content":"my solution\n","description":"my solution"},{"id":43,"href":"/tags/hugo.html","title":"hugo","parent":"Tags","content":"","description":""},{"id":44,"href":"/tags/trash-talk.html","title":"trash talk","parent":"Tags","content":"","description":""},{"id":45,"href":"/Programming/Algorithm/Grind75/Week1/Best-Time-to-Buy-and-Sell-Stock.html","title":"Best Time to Buy and Sell Stock","parent":"Week1","content":"my solution\n","description":"my solution"},{"id":46,"href":"/tags/infra.html","title":"infra","parent":"Tags","content":"","description":""},{"id":47,"href":"/Programming/Languages/Java/Spring-Boot/Integrated-Spring/Integrate-Spirng-1.html","title":"Integrate Spring 1","parent":"Integrated Spring","content":"My same tree solution\n","description":"My same tree solution"},{"id":48,"href":"/Programming/Languages/Java/Spring-Boot/Integrated-Spring/same-tree.html","title":"Integrate Spring 2","parent":"Integrated Spring","content":"my solution\n","description":"my solution"},{"id":49,"href":"/tags/leetcode.html","title":"leetcode","parent":"Tags","content":"","description":""},{"id":50,"href":"/Programming/Algorithm/Blind75/Tree/MaximumDepthOfBinaryTree.html","title":"Maximum Depth of Binary Tree","parent":"Tree","content":"My same tree solution\n","description":"My same tree solution"},{"id":51,"href":"/Programming/Algorithm/Blind75/Tree/SameTree.html","title":"Maximum Depth of Binary Tree","parent":"Tree","content":"my solution\n","description":"my solution"},{"id":52,"href":"/Programming/Algorithm/Grind75/Week2/Maximum-Depth-of-Binary-Tree.html","title":"Maximum Depth of Binary Tree","parent":"Week2","content":"My same tree solution\n","description":"My same tree solution"},{"id":53,"href":"/Programming/Algorithm/Grind75/Week2/same-tree.html","title":"Maximum Depth of Binary Tree","parent":"Week2","content":"my solution\n","description":"my solution"},{"id":54,"href":"/Programming/Languages/Java/Spring-Boot/Getting-started-with-Spring/two-sum.html","title":"Spring 2","parent":"Getting Started With Spring","content":"asdf My two sum solution\n","description":"asdf My two sum solution"},{"id":55,"href":"/Programming/Languages/Java/Spring-Boot/Getting-started-with-Spring/Start.html","title":"Start","parent":"Getting Started With Spring","content":"my solution\n","description":"my solution"},{"id":56,"href":"/Programming/Algorithm/Grind75/Week1/two-sum.html","title":"two sum","parent":"Week1","content":"My two sum solution\n","description":"My two sum solution"},{"id":57,"href":"/","title":"","parent":"","content":" Jottings Programming Algorithm Language Site Story Why Hugo Hugo GitHub Page GitHub Action w/ VPS Install SSL Typora \u0026#43; Upic ","description":" Jottings Programming Algorithm Language Site Story Why Hugo Hugo GitHub Page GitHub Action w/ VPS Install SSL Typora \u0026#43; Upic "},{"id":58,"href":"/Programming/Algorithm/Blind75/Array.html","title":"Array","parent":"Blind 75","content":"","description":""},{"id":59,"href":"/Programming/Algorithm/Blind75/Tree.html","title":"Tree","parent":"Blind 75","content":"","description":""},{"id":60,"href":"/Programming/Algorithm/Grind75/Week1.html","title":"Week1","parent":"Grind 75","content":"","description":""},{"id":61,"href":"/Programming/Algorithm/Grind75/Week2.html","title":"Week2","parent":"Grind 75","content":"","description":""},{"id":62,"href":"/Programming/Languages/Java/Spring-Boot/Getting-started-with-Spring.html","title":"Getting Started With Spring","parent":"Spring Boot","content":"","description":""},{"id":63,"href":"/Programming/Languages/Java/Spring-Boot/Integrated-Spring.html","title":"Integrated Spring","parent":"Spring Boot","content":"","description":""},{"id":64,"href":"/Programming/Algorithm.html","title":"Algorithm","parent":"Programming","content":" Princeton Algorithms Blind 75 Grind 75 ","description":" Princeton Algorithms Blind 75 Grind 75 "},{"id":65,"href":"/Programming/Languages.html","title":"Language","parent":"Programming","content":"My leetcode blind 75 trip\u0026hellip;\nPHP JAVA Miscellaneous Chpher ","description":"My leetcode blind 75 trip\u0026hellip;\nPHP JAVA Miscellaneous Chpher "},{"id":66,"href":"/Programming/Algorithm/Algs4Princeton/Week1/AnalysisOfAlgorithm/MathematicalModels.html","title":"Mathematical Models","parent":"Analysis Of Algorithm","content":"","description":""},{"id":67,"href":"/Programming/Algorithm/Algs4Princeton.html","title":"Princeton Algorithms","parent":"Algorithm","content":" Week 1 Union Find Dynamic Connectivity Quick Find Quick Union Weighted Quick Union Analysis Of Algorithm Week 2 Stack And Queue ","description":" Week 1 Union Find Dynamic Connectivity Quick Find Quick Union Weighted Quick Union Analysis Of Algorithm Week 2 Stack And Queue "},{"id":68,"href":"/Programming.html","title":"Programming","parent":"","content":" Algorithm Language Site Story Why Hugo Hugo GitHub Page GitHub Action w/ VPS Install SSL Typora \u0026#43; Upic ","description":" Algorithm Language Site Story Why Hugo Hugo GitHub Page GitHub Action w/ VPS Install SSL Typora \u0026#43; Upic "},{"id":69,"href":"/Programming/Algorithm/Algs4Princeton/Week2/StackAndQueue.html","title":"Stack And Queue","parent":"Week 2","content":" Stacks Resizing Arrays ","description":" Stacks Resizing Arrays "}]